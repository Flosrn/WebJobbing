import { Inject, Injectable, InjectionToken, NgModule, Pipe } from '@angular/core';
import { Observable as Observable$1 } from 'rxjs/Observable';
import { Subscription as Subscription$1 } from 'rxjs/Subscription';
import 'rxjs/add/observable/interval';
import 'rxjs/add/operator/startWith';
/**
 * @category Common Helpers
 * @summary Is the given argument an instance of Date?
 *
 * @description
 * Is the given argument an instance of Date?
 *
 * @param {*} argument - the argument to check
 * @returns {Boolean} the given argument is an instance of Date
 *
 * @example
 * // Is 'mayonnaise' a Date?
 * var result = isDate('mayonnaise')
 * //=> false
 */
function isDate(argument) {
    return argument instanceof Date;
}
var is_date = isDate;
var MILLISECONDS_IN_HOUR = 3600000;
var MILLISECONDS_IN_MINUTE = 60000;
var DEFAULT_ADDITIONAL_DIGITS = 2;
var parseTokenDateTimeDelimeter = /[T ]/;
var parseTokenPlainTime = /:/;
// year tokens
var parseTokenYY = /^(\d{2})$/;
var parseTokensYYY = [
    /^([+-]\d{2})$/,
    /^([+-]\d{3})$/,
    /^([+-]\d{4})$/ // 2 additional digits
];
var parseTokenYYYY = /^(\d{4})/;
var parseTokensYYYYY = [
    /^([+-]\d{4})/,
    /^([+-]\d{5})/,
    /^([+-]\d{6})/ // 2 additional digits
];
// date tokens
var parseTokenMM = /^-(\d{2})$/;
var parseTokenDDD = /^-?(\d{3})$/;
var parseTokenMMDD = /^-?(\d{2})-?(\d{2})$/;
var parseTokenWww = /^-?W(\d{2})$/;
var parseTokenWwwD = /^-?W(\d{2})-?(\d{1})$/;
// time tokens
var parseTokenHH = /^(\d{2}([.,]\d*)?)$/;
var parseTokenHHMM = /^(\d{2}):?(\d{2}([.,]\d*)?)$/;
var parseTokenHHMMSS = /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/;
// timezone tokens
var parseTokenTimezone = /([Z+-].*)$/;
var parseTokenTimezoneZ = /^(Z)$/;
var parseTokenTimezoneHH = /^([+-])(\d{2})$/;
var parseTokenTimezoneHHMM = /^([+-])(\d{2}):?(\d{2})$/;
/**
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If an argument is a string, the function tries to parse it.
 * Function accepts complete ISO 8601 formats as well as partial implementations.
 * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
 *
 * If all above fails, the function passes the given argument to Date constructor.
 *
 * @param {Date|String|Number} argument - the value to convert
 * @param {Object} [options] - the object with options
 * @param {0 | 1 | 2} [options.additionalDigits=2] - the additional number of digits in the extended year format
 * @returns {Date} the parsed date in the local time zone
 *
 * @example
 * // Convert string '2014-02-11T11:30:30' to date:
 * var result = parse('2014-02-11T11:30:30')
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Parse string '+02014101',
 * // if the additional number of digits in the extended year format is 1:
 * var result = parse('+02014101', {additionalDigits: 1})
 * //=> Fri Apr 11 2014 00:00:00
 */
function parse(argument, dirtyOptions) {
    if (is_date(argument)) {
        // Prevent the date to lose the milliseconds when passed to new Date() in IE10
        return new Date(argument.getTime());
    }
    else if (typeof argument !== 'string') {
        return new Date(argument);
    }
    var options = dirtyOptions || {};
    var additionalDigits = options.additionalDigits;
    if (additionalDigits == null) {
        additionalDigits = DEFAULT_ADDITIONAL_DIGITS;
    }
    else {
        additionalDigits = Number(additionalDigits);
    }
    var dateStrings = splitDateString(argument);
    var parseYearResult = parseYear(dateStrings.date, additionalDigits);
    var year = parseYearResult.year;
    var restDateString = parseYearResult.restDateString;
    var date = parseDate(restDateString, year);
    if (date) {
        var timestamp = date.getTime();
        var time = 0;
        var offset;
        if (dateStrings.time) {
            time = parseTime(dateStrings.time);
        }
        if (dateStrings.timezone) {
            offset = parseTimezone(dateStrings.timezone);
        }
        else {
            // get offset accurate to hour in timezones that change offset
            offset = new Date(timestamp + time).getTimezoneOffset();
            offset = new Date(timestamp + time + offset * MILLISECONDS_IN_MINUTE).getTimezoneOffset();
        }
        return new Date(timestamp + time + offset * MILLISECONDS_IN_MINUTE);
    }
    else {
        return new Date(argument);
    }
}
function splitDateString(dateString) {
    var dateStrings = {};
    var array = dateString.split(parseTokenDateTimeDelimeter);
    var timeString;
    if (parseTokenPlainTime.test(array[0])) {
        dateStrings.date = null;
        timeString = array[0];
    }
    else {
        dateStrings.date = array[0];
        timeString = array[1];
    }
    if (timeString) {
        var token = parseTokenTimezone.exec(timeString);
        if (token) {
            dateStrings.time = timeString.replace(token[1], '');
            dateStrings.timezone = token[1];
        }
        else {
            dateStrings.time = timeString;
        }
    }
    return dateStrings;
}
function parseYear(dateString, additionalDigits) {
    var parseTokenYYY = parseTokensYYY[additionalDigits];
    var parseTokenYYYYY = parseTokensYYYYY[additionalDigits];
    var token;
    // YYYY or ±YYYYY
    token = parseTokenYYYY.exec(dateString) || parseTokenYYYYY.exec(dateString);
    if (token) {
        var yearString = token[1];
        return {
            year: parseInt(yearString, 10),
            restDateString: dateString.slice(yearString.length)
        };
    }
    // YY or ±YYY
    token = parseTokenYY.exec(dateString) || parseTokenYYY.exec(dateString);
    if (token) {
        var centuryString = token[1];
        return {
            year: parseInt(centuryString, 10) * 100,
            restDateString: dateString.slice(centuryString.length)
        };
    }
    // Invalid ISO-formatted year
    return {
        year: null
    };
}
function parseDate(dateString, year) {
    // Invalid ISO-formatted year
    if (year === null) {
        return null;
    }
    var token;
    var date;
    var month;
    var week;
    // YYYY
    if (dateString.length === 0) {
        date = new Date(0);
        date.setUTCFullYear(year);
        return date;
    }
    // YYYY-MM
    token = parseTokenMM.exec(dateString);
    if (token) {
        date = new Date(0);
        month = parseInt(token[1], 10) - 1;
        date.setUTCFullYear(year, month);
        return date;
    }
    // YYYY-DDD or YYYYDDD
    token = parseTokenDDD.exec(dateString);
    if (token) {
        date = new Date(0);
        var dayOfYear = parseInt(token[1], 10);
        date.setUTCFullYear(year, 0, dayOfYear);
        return date;
    }
    // YYYY-MM-DD or YYYYMMDD
    token = parseTokenMMDD.exec(dateString);
    if (token) {
        date = new Date(0);
        month = parseInt(token[1], 10) - 1;
        var day = parseInt(token[2], 10);
        date.setUTCFullYear(year, month, day);
        return date;
    }
    // YYYY-Www or YYYYWww
    token = parseTokenWww.exec(dateString);
    if (token) {
        week = parseInt(token[1], 10) - 1;
        return dayOfISOYear(year, week);
    }
    // YYYY-Www-D or YYYYWwwD
    token = parseTokenWwwD.exec(dateString);
    if (token) {
        week = parseInt(token[1], 10) - 1;
        var dayOfWeek = parseInt(token[2], 10) - 1;
        return dayOfISOYear(year, week, dayOfWeek);
    }
    // Invalid ISO-formatted date
    return null;
}
function parseTime(timeString) {
    var token;
    var hours;
    var minutes;
    // hh
    token = parseTokenHH.exec(timeString);
    if (token) {
        hours = parseFloat(token[1].replace(',', '.'));
        return (hours % 24) * MILLISECONDS_IN_HOUR;
    }
    // hh:mm or hhmm
    token = parseTokenHHMM.exec(timeString);
    if (token) {
        hours = parseInt(token[1], 10);
        minutes = parseFloat(token[2].replace(',', '.'));
        return (hours % 24) * MILLISECONDS_IN_HOUR +
            minutes * MILLISECONDS_IN_MINUTE;
    }
    // hh:mm:ss or hhmmss
    token = parseTokenHHMMSS.exec(timeString);
    if (token) {
        hours = parseInt(token[1], 10);
        minutes = parseInt(token[2], 10);
        var seconds = parseFloat(token[3].replace(',', '.'));
        return (hours % 24) * MILLISECONDS_IN_HOUR +
            minutes * MILLISECONDS_IN_MINUTE +
            seconds * 1000;
    }
    // Invalid ISO-formatted time
    return null;
}
function parseTimezone(timezoneString) {
    var token;
    var absoluteOffset;
    // Z
    token = parseTokenTimezoneZ.exec(timezoneString);
    if (token) {
        return 0;
    }
    // ±hh
    token = parseTokenTimezoneHH.exec(timezoneString);
    if (token) {
        absoluteOffset = parseInt(token[2], 10) * 60;
        return (token[1] === '+') ? -absoluteOffset : absoluteOffset;
    }
    // ±hh:mm or ±hhmm
    token = parseTokenTimezoneHHMM.exec(timezoneString);
    if (token) {
        absoluteOffset = parseInt(token[2], 10) * 60 + parseInt(token[3], 10);
        return (token[1] === '+') ? -absoluteOffset : absoluteOffset;
    }
    return 0;
}
function dayOfISOYear(isoYear, week, day) {
    week = week || 0;
    day = day || 0;
    var date = new Date(0);
    date.setUTCFullYear(isoYear, 0, 4);
    var fourthOfJanuaryDay = date.getUTCDay() || 7;
    var diff = week * 7 + day + 1 - fourthOfJanuaryDay;
    date.setUTCDate(date.getUTCDate() + diff);
    return date;
}
var parse_1 = parse;
/**
 * @category Year Helpers
 * @summary Return the start of a year for the given date.
 *
 * @description
 * Return the start of a year for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|String|Number} date - the original date
 * @returns {Date} the start of a year
 *
 * @example
 * // The start of a year for 2 September 2014 11:55:00:
 * var result = startOfYear(new Date(2014, 8, 2, 11, 55, 00))
 * //=> Wed Jan 01 2014 00:00:00
 */
function startOfYear(dirtyDate) {
    var cleanDate = parse_1(dirtyDate);
    var date = new Date(0);
    date.setFullYear(cleanDate.getFullYear(), 0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
}
var start_of_year = startOfYear;
/**
 * @category Day Helpers
 * @summary Return the start of a day for the given date.
 *
 * @description
 * Return the start of a day for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|String|Number} date - the original date
 * @returns {Date} the start of a day
 *
 * @example
 * // The start of a day for 2 September 2014 11:55:00:
 * var result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 02 2014 00:00:00
 */
function startOfDay(dirtyDate) {
    var date = parse_1(dirtyDate);
    date.setHours(0, 0, 0, 0);
    return date;
}
var start_of_day = startOfDay;
var MILLISECONDS_IN_MINUTE$1 = 60000;
var MILLISECONDS_IN_DAY = 86400000;
/**
 * @category Day Helpers
 * @summary Get the number of calendar days between the given dates.
 *
 * @description
 * Get the number of calendar days between the given dates.
 *
 * @param {Date|String|Number} dateLeft - the later date
 * @param {Date|String|Number} dateRight - the earlier date
 * @returns {Number} the number of calendar days
 *
 * @example
 * // How many calendar days are between
 * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
 * var result = differenceInCalendarDays(
 *   new Date(2012, 6, 2, 0, 0),
 *   new Date(2011, 6, 2, 23, 0)
 * )
 * //=> 366
 */
function differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {
    var startOfDayLeft = start_of_day(dirtyDateLeft);
    var startOfDayRight = start_of_day(dirtyDateRight);
    var timestampLeft = startOfDayLeft.getTime() -
        startOfDayLeft.getTimezoneOffset() * MILLISECONDS_IN_MINUTE$1;
    var timestampRight = startOfDayRight.getTime() -
        startOfDayRight.getTimezoneOffset() * MILLISECONDS_IN_MINUTE$1;
    // Round the number of days to the nearest integer
    // because the number of milliseconds in a day is not constant
    // (e.g. it's different in the day of the daylight saving time clock shift)
    return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY);
}
var difference_in_calendar_days = differenceInCalendarDays;
/**
 * @category Day Helpers
 * @summary Get the day of the year of the given date.
 *
 * @description
 * Get the day of the year of the given date.
 *
 * @param {Date|String|Number} date - the given date
 * @returns {Number} the day of year
 *
 * @example
 * // Which day of the year is 2 July 2014?
 * var result = getDayOfYear(new Date(2014, 6, 2))
 * //=> 183
 */
function getDayOfYear(dirtyDate) {
    var date = parse_1(dirtyDate);
    var diff = difference_in_calendar_days(date, start_of_year(date));
    var dayOfYear = diff + 1;
    return dayOfYear;
}
var get_day_of_year = getDayOfYear;
/**
 * @category Week Helpers
 * @summary Return the start of a week for the given date.
 *
 * @description
 * Return the start of a week for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|String|Number} date - the original date
 * @param {Object} [options] - the object with options
 * @param {Number} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @returns {Date} the start of a week
 *
 * @example
 * // The start of a week for 2 September 2014 11:55:00:
 * var result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // If the week starts on Monday, the start of the week for 2 September 2014 11:55:00:
 * var result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0), {weekStartsOn: 1})
 * //=> Mon Sep 01 2014 00:00:00
 */
function startOfWeek(dirtyDate, dirtyOptions) {
    var weekStartsOn = dirtyOptions ? (Number(dirtyOptions.weekStartsOn) || 0) : 0;
    var date = parse_1(dirtyDate);
    var day = date.getDay();
    var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    date.setDate(date.getDate() - diff);
    date.setHours(0, 0, 0, 0);
    return date;
}
var start_of_week = startOfWeek;
/**
 * @category ISO Week Helpers
 * @summary Return the start of an ISO week for the given date.
 *
 * @description
 * Return the start of an ISO week for the given date.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @param {Date|String|Number} date - the original date
 * @returns {Date} the start of an ISO week
 *
 * @example
 * // The start of an ISO week for 2 September 2014 11:55:00:
 * var result = startOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Mon Sep 01 2014 00:00:00
 */
function startOfISOWeek(dirtyDate) {
    return start_of_week(dirtyDate, { weekStartsOn: 1 });
}
var start_of_iso_week = startOfISOWeek;
/**
 * @category ISO Week-Numbering Year Helpers
 * @summary Get the ISO week-numbering year of the given date.
 *
 * @description
 * Get the ISO week-numbering year of the given date,
 * which always starts 3 days before the year's first Thursday.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @param {Date|String|Number} date - the given date
 * @returns {Number} the ISO week-numbering year
 *
 * @example
 * // Which ISO-week numbering year is 2 January 2005?
 * var result = getISOYear(new Date(2005, 0, 2))
 * //=> 2004
 */
function getISOYear(dirtyDate) {
    var date = parse_1(dirtyDate);
    var year = date.getFullYear();
    var fourthOfJanuaryOfNextYear = new Date(0);
    fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
    fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
    var startOfNextYear = start_of_iso_week(fourthOfJanuaryOfNextYear);
    var fourthOfJanuaryOfThisYear = new Date(0);
    fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
    fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
    var startOfThisYear = start_of_iso_week(fourthOfJanuaryOfThisYear);
    if (date.getTime() >= startOfNextYear.getTime()) {
        return year + 1;
    }
    else if (date.getTime() >= startOfThisYear.getTime()) {
        return year;
    }
    else {
        return year - 1;
    }
}
var get_iso_year = getISOYear;
/**
 * @category ISO Week-Numbering Year Helpers
 * @summary Return the start of an ISO week-numbering year for the given date.
 *
 * @description
 * Return the start of an ISO week-numbering year,
 * which always starts 3 days before the year's first Thursday.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @param {Date|String|Number} date - the original date
 * @returns {Date} the start of an ISO year
 *
 * @example
 * // The start of an ISO week-numbering year for 2 July 2005:
 * var result = startOfISOYear(new Date(2005, 6, 2))
 * //=> Mon Jan 03 2005 00:00:00
 */
function startOfISOYear(dirtyDate) {
    var year = get_iso_year(dirtyDate);
    var fourthOfJanuary = new Date(0);
    fourthOfJanuary.setFullYear(year, 0, 4);
    fourthOfJanuary.setHours(0, 0, 0, 0);
    var date = start_of_iso_week(fourthOfJanuary);
    return date;
}
var start_of_iso_year = startOfISOYear;
var MILLISECONDS_IN_WEEK = 604800000;
/**
 * @category ISO Week Helpers
 * @summary Get the ISO week of the given date.
 *
 * @description
 * Get the ISO week of the given date.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @param {Date|String|Number} date - the given date
 * @returns {Number} the ISO week
 *
 * @example
 * // Which week of the ISO-week numbering year is 2 January 2005?
 * var result = getISOWeek(new Date(2005, 0, 2))
 * //=> 53
 */
function getISOWeek(dirtyDate) {
    var date = parse_1(dirtyDate);
    var diff = start_of_iso_week(date).getTime() - start_of_iso_year(date).getTime();
    // Round the number of days to the nearest integer
    // because the number of milliseconds in a week is not constant
    // (e.g. it's different in the week of the daylight saving time clock shift)
    return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}
var get_iso_week = getISOWeek;
/**
 * @category Common Helpers
 * @summary Is the given date valid?
 *
 * @description
 * Returns false if argument is Invalid Date and true otherwise.
 * Invalid Date is a Date, whose time value is NaN.
 *
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * @param {Date} date - the date to check
 * @returns {Boolean} the date is valid
 * @throws {TypeError} argument must be an instance of Date
 *
 * @example
 * // For the valid date:
 * var result = isValid(new Date(2014, 1, 31))
 * //=> true
 *
 * @example
 * // For the invalid date:
 * var result = isValid(new Date(''))
 * //=> false
 */
function isValid(dirtyDate) {
    if (is_date(dirtyDate)) {
        return !isNaN(dirtyDate);
    }
    else {
        throw new TypeError(toString.call(dirtyDate) + ' is not an instance of Date');
    }
}
var is_valid = isValid;
function buildDistanceInWordsLocale() {
    var distanceInWordsLocale = {
        lessThanXSeconds: {
            one: 'less than a second',
            other: 'less than {{count}} seconds'
        },
        xSeconds: {
            one: '1 second',
            other: '{{count}} seconds'
        },
        halfAMinute: 'half a minute',
        lessThanXMinutes: {
            one: 'less than a minute',
            other: 'less than {{count}} minutes'
        },
        xMinutes: {
            one: '1 minute',
            other: '{{count}} minutes'
        },
        aboutXHours: {
            one: 'about 1 hour',
            other: 'about {{count}} hours'
        },
        xHours: {
            one: '1 hour',
            other: '{{count}} hours'
        },
        xDays: {
            one: '1 day',
            other: '{{count}} days'
        },
        aboutXMonths: {
            one: 'about 1 month',
            other: 'about {{count}} months'
        },
        xMonths: {
            one: '1 month',
            other: '{{count}} months'
        },
        aboutXYears: {
            one: 'about 1 year',
            other: 'about {{count}} years'
        },
        xYears: {
            one: '1 year',
            other: '{{count}} years'
        },
        overXYears: {
            one: 'over 1 year',
            other: 'over {{count}} years'
        },
        almostXYears: {
            one: 'almost 1 year',
            other: 'almost {{count}} years'
        }
    };
    function localize(token, count, options) {
        options = options || {};
        var result;
        if (typeof distanceInWordsLocale[token] === 'string') {
            result = distanceInWordsLocale[token];
        }
        else if (count === 1) {
            result = distanceInWordsLocale[token].one;
        }
        else {
            result = distanceInWordsLocale[token].other.replace('{{count}}', count);
        }
        if (options.addSuffix) {
            if (options.comparison > 0) {
                return 'in ' + result;
            }
            else {
                return result + ' ago';
            }
        }
        return result;
    }
    return {
        localize: localize
    };
}
var build_distance_in_words_locale = buildDistanceInWordsLocale;
var commonFormatterKeys = [
    'M', 'MM', 'Q', 'D', 'DD', 'DDD', 'DDDD', 'd',
    'E', 'W', 'WW', 'YY', 'YYYY', 'GG', 'GGGG',
    'H', 'HH', 'h', 'hh', 'm', 'mm',
    's', 'ss', 'S', 'SS', 'SSS',
    'Z', 'ZZ', 'X', 'x'
];
function buildFormattingTokensRegExp(formatters) {
    var formatterKeys = [];
    for (var key in formatters) {
        if (formatters.hasOwnProperty(key)) {
            formatterKeys.push(key);
        }
    }
    var formattingTokens = commonFormatterKeys
        .concat(formatterKeys)
        .sort()
        .reverse();
    var formattingTokensRegExp = new RegExp('(\\[[^\\[]*\\])|(\\\\)?' + '(' + formattingTokens.join('|') + '|.)', 'g');
    return formattingTokensRegExp;
}
var build_formatting_tokens_reg_exp = buildFormattingTokensRegExp;
function buildFormatLocale() {
    // Note: in English, the names of days of the week and months are capitalized.
    // If you are making a new locale based on this one, check if the same is true for the language you're working on.
    // Generally, formatted dates should look like they are in the middle of a sentence,
    // e.g. in Spanish language the weekdays and months should be in the lowercase.
    var months3char = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    var monthsFull = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
    var weekdays2char = ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'];
    var weekdays3char = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    var weekdaysFull = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    var meridiemUppercase = ['AM', 'PM'];
    var meridiemLowercase = ['am', 'pm'];
    var meridiemFull = ['a.m.', 'p.m.'];
    var formatters = {
        // Month: Jan, Feb, ..., Dec
        'MMM': function (date) {
            return months3char[date.getMonth()];
        },
        // Month: January, February, ..., December
        'MMMM': function (date) {
            return monthsFull[date.getMonth()];
        },
        // Day of week: Su, Mo, ..., Sa
        'dd': function (date) {
            return weekdays2char[date.getDay()];
        },
        // Day of week: Sun, Mon, ..., Sat
        'ddd': function (date) {
            return weekdays3char[date.getDay()];
        },
        // Day of week: Sunday, Monday, ..., Saturday
        'dddd': function (date) {
            return weekdaysFull[date.getDay()];
        },
        // AM, PM
        'A': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemUppercase[1] : meridiemUppercase[0];
        },
        // am, pm
        'a': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemLowercase[1] : meridiemLowercase[0];
        },
        // a.m., p.m.
        'aa': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemFull[1] : meridiemFull[0];
        }
    };
    // Generate ordinal version of formatters: M -> Mo, D -> Do, etc.
    var ordinalFormatters = ['M', 'D', 'DDD', 'd', 'Q', 'W'];
    ordinalFormatters.forEach(function (formatterToken) {
        formatters[formatterToken + 'o'] = function (date, formatters) {
            return ordinal(formatters[formatterToken](date));
        };
    });
    return {
        formatters: formatters,
        formattingTokensRegExp: build_formatting_tokens_reg_exp(formatters)
    };
}
function ordinal(number) {
    var rem100 = number % 100;
    if (rem100 > 20 || rem100 < 10) {
        switch (rem100 % 10) {
            case 1:
                return number + 'st';
            case 2:
                return number + 'nd';
            case 3:
                return number + 'rd';
        }
    }
    return number + 'th';
}
var build_format_locale = buildFormatLocale;
/**
 * @category Locales
 * @summary English locale.
 */
var en = {
    distanceInWords: build_distance_in_words_locale(),
    format: build_format_locale()
};
var en$2 = Object.freeze({
    default: en,
    __moduleExports: en
});
/**
 * @category Common Helpers
 * @summary Format the date.
 *
 * @description
 * Return the formatted date string in the given format.
 *
 * Accepted tokens:
 * | Unit                    | Token | Result examples                  |
 * |-------------------------|-------|----------------------------------|
 * | Month                   | M     | 1, 2, ..., 12                    |
 * |                         | Mo    | 1st, 2nd, ..., 12th              |
 * |                         | MM    | 01, 02, ..., 12                  |
 * |                         | MMM   | Jan, Feb, ..., Dec               |
 * |                         | MMMM  | January, February, ..., December |
 * | Quarter                 | Q     | 1, 2, 3, 4                       |
 * |                         | Qo    | 1st, 2nd, 3rd, 4th               |
 * | Day of month            | D     | 1, 2, ..., 31                    |
 * |                         | Do    | 1st, 2nd, ..., 31st              |
 * |                         | DD    | 01, 02, ..., 31                  |
 * | Day of year             | DDD   | 1, 2, ..., 366                   |
 * |                         | DDDo  | 1st, 2nd, ..., 366th             |
 * |                         | DDDD  | 001, 002, ..., 366               |
 * | Day of week             | d     | 0, 1, ..., 6                     |
 * |                         | do    | 0th, 1st, ..., 6th               |
 * |                         | dd    | Su, Mo, ..., Sa                  |
 * |                         | ddd   | Sun, Mon, ..., Sat               |
 * |                         | dddd  | Sunday, Monday, ..., Saturday    |
 * | Day of ISO week         | E     | 1, 2, ..., 7                     |
 * | ISO week                | W     | 1, 2, ..., 53                    |
 * |                         | Wo    | 1st, 2nd, ..., 53rd              |
 * |                         | WW    | 01, 02, ..., 53                  |
 * | Year                    | YY    | 00, 01, ..., 99                  |
 * |                         | YYYY  | 1900, 1901, ..., 2099            |
 * | ISO week-numbering year | GG    | 00, 01, ..., 99                  |
 * |                         | GGGG  | 1900, 1901, ..., 2099            |
 * | AM/PM                   | A     | AM, PM                           |
 * |                         | a     | am, pm                           |
 * |                         | aa    | a.m., p.m.                       |
 * | Hour                    | H     | 0, 1, ... 23                     |
 * |                         | HH    | 00, 01, ... 23                   |
 * |                         | h     | 1, 2, ..., 12                    |
 * |                         | hh    | 01, 02, ..., 12                  |
 * | Minute                  | m     | 0, 1, ..., 59                    |
 * |                         | mm    | 00, 01, ..., 59                  |
 * | Second                  | s     | 0, 1, ..., 59                    |
 * |                         | ss    | 00, 01, ..., 59                  |
 * | 1/10 of second          | S     | 0, 1, ..., 9                     |
 * | 1/100 of second         | SS    | 00, 01, ..., 99                  |
 * | Millisecond             | SSS   | 000, 001, ..., 999               |
 * | Timezone                | Z     | -01:00, +00:00, ... +12:00       |
 * |                         | ZZ    | -0100, +0000, ..., +1200         |
 * | Seconds timestamp       | X     | 512969520                        |
 * | Milliseconds timestamp  | x     | 512969520900                     |
 *
 * The characters wrapped in square brackets are escaped.
 *
 * The result may vary by locale.
 *
 * @param {Date|String|Number} date - the original date
 * @param {String} [format='YYYY-MM-DDTHH:mm:ss.SSSZ'] - the string of tokens
 * @param {Object} [options] - the object with options
 * @param {Object} [options.locale=enLocale] - the locale object
 * @returns {String} the formatted date string
 *
 * @example
 * // Represent 11 February 2014 in middle-endian format:
 * var result = format(
 *   new Date(2014, 1, 11),
 *   'MM/DD/YYYY'
 * )
 * //=> '02/11/2014'
 *
 * @example
 * // Represent 2 July 2014 in Esperanto:
 * var eoLocale = require('date-fns/locale/eo')
 * var result = format(
 *   new Date(2014, 6, 2),
 *   'Do [de] MMMM YYYY',
 *   {locale: eoLocale}
 * )
 * //=> '2-a de julio 2014'
 */
function format(dirtyDate, dirtyFormatStr, dirtyOptions) {
    var formatStr = dirtyFormatStr ? String(dirtyFormatStr) : 'YYYY-MM-DDTHH:mm:ss.SSSZ';
    var options = dirtyOptions || {};
    var locale = options.locale;
    var localeFormatters = en.format.formatters;
    var formattingTokensRegExp = en.format.formattingTokensRegExp;
    if (locale && locale.format && locale.format.formatters) {
        localeFormatters = locale.format.formatters;
        if (locale.format.formattingTokensRegExp) {
            formattingTokensRegExp = locale.format.formattingTokensRegExp;
        }
    }
    var date = parse_1(dirtyDate);
    if (!is_valid(date)) {
        return 'Invalid Date';
    }
    var formatFn = buildFormatFn(formatStr, localeFormatters, formattingTokensRegExp);
    return formatFn(date);
}
var formatters = {
    // Month: 1, 2, ..., 12
    'M': function (date) {
        return date.getMonth() + 1;
    },
    // Month: 01, 02, ..., 12
    'MM': function (date) {
        return addLeadingZeros(date.getMonth() + 1, 2);
    },
    // Quarter: 1, 2, 3, 4
    'Q': function (date) {
        return Math.ceil((date.getMonth() + 1) / 3);
    },
    // Day of month: 1, 2, ..., 31
    'D': function (date) {
        return date.getDate();
    },
    // Day of month: 01, 02, ..., 31
    'DD': function (date) {
        return addLeadingZeros(date.getDate(), 2);
    },
    // Day of year: 1, 2, ..., 366
    'DDD': function (date) {
        return get_day_of_year(date);
    },
    // Day of year: 001, 002, ..., 366
    'DDDD': function (date) {
        return addLeadingZeros(get_day_of_year(date), 3);
    },
    // Day of week: 0, 1, ..., 6
    'd': function (date) {
        return date.getDay();
    },
    // Day of ISO week: 1, 2, ..., 7
    'E': function (date) {
        return date.getDay() || 7;
    },
    // ISO week: 1, 2, ..., 53
    'W': function (date) {
        return get_iso_week(date);
    },
    // ISO week: 01, 02, ..., 53
    'WW': function (date) {
        return addLeadingZeros(get_iso_week(date), 2);
    },
    // Year: 00, 01, ..., 99
    'YY': function (date) {
        return addLeadingZeros(date.getFullYear(), 4).substr(2);
    },
    // Year: 1900, 1901, ..., 2099
    'YYYY': function (date) {
        return addLeadingZeros(date.getFullYear(), 4);
    },
    // ISO week-numbering year: 00, 01, ..., 99
    'GG': function (date) {
        return String(get_iso_year(date)).substr(2);
    },
    // ISO week-numbering year: 1900, 1901, ..., 2099
    'GGGG': function (date) {
        return get_iso_year(date);
    },
    // Hour: 0, 1, ... 23
    'H': function (date) {
        return date.getHours();
    },
    // Hour: 00, 01, ..., 23
    'HH': function (date) {
        return addLeadingZeros(date.getHours(), 2);
    },
    // Hour: 1, 2, ..., 12
    'h': function (date) {
        var hours = date.getHours();
        if (hours === 0) {
            return 12;
        }
        else if (hours > 12) {
            return hours % 12;
        }
        else {
            return hours;
        }
    },
    // Hour: 01, 02, ..., 12
    'hh': function (date) {
        return addLeadingZeros(formatters['h'](date), 2);
    },
    // Minute: 0, 1, ..., 59
    'm': function (date) {
        return date.getMinutes();
    },
    // Minute: 00, 01, ..., 59
    'mm': function (date) {
        return addLeadingZeros(date.getMinutes(), 2);
    },
    // Second: 0, 1, ..., 59
    's': function (date) {
        return date.getSeconds();
    },
    // Second: 00, 01, ..., 59
    'ss': function (date) {
        return addLeadingZeros(date.getSeconds(), 2);
    },
    // 1/10 of second: 0, 1, ..., 9
    'S': function (date) {
        return Math.floor(date.getMilliseconds() / 100);
    },
    // 1/100 of second: 00, 01, ..., 99
    'SS': function (date) {
        return addLeadingZeros(Math.floor(date.getMilliseconds() / 10), 2);
    },
    // Millisecond: 000, 001, ..., 999
    'SSS': function (date) {
        return addLeadingZeros(date.getMilliseconds(), 3);
    },
    // Timezone: -01:00, +00:00, ... +12:00
    'Z': function (date) {
        return formatTimezone(date.getTimezoneOffset(), ':');
    },
    // Timezone: -0100, +0000, ... +1200
    'ZZ': function (date) {
        return formatTimezone(date.getTimezoneOffset());
    },
    // Seconds timestamp: 512969520
    'X': function (date) {
        return Math.floor(date.getTime() / 1000);
    },
    // Milliseconds timestamp: 512969520900
    'x': function (date) {
        return date.getTime();
    }
};
function buildFormatFn(formatStr, localeFormatters, formattingTokensRegExp) {
    var array = formatStr.match(formattingTokensRegExp);
    var length = array.length;
    var i;
    var formatter;
    for (i = 0; i < length; i++) {
        formatter = localeFormatters[array[i]] || formatters[array[i]];
        if (formatter) {
            array[i] = formatter;
        }
        else {
            array[i] = removeFormattingTokens(array[i]);
        }
    }
    return function (date) {
        var output = '';
        for (var i = 0; i < length; i++) {
            if (array[i] instanceof Function) {
                output += array[i](date, formatters);
            }
            else {
                output += array[i];
            }
        }
        return output;
    };
}
function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|]$/g, '');
    }
    return input.replace(/\\/g, '');
}
function formatTimezone(offset, delimeter) {
    delimeter = delimeter || '';
    var sign = offset > 0 ? '-' : '+';
    var absOffset = Math.abs(offset);
    var hours = Math.floor(absOffset / 60);
    var minutes = absOffset % 60;
    return sign + addLeadingZeros(hours, 2) + delimeter + addLeadingZeros(minutes, 2);
}
function addLeadingZeros(number, targetLength) {
    var output = Math.abs(number).toString();
    while (output.length < targetLength) {
        output = '0' + output;
    }
    return output;
}
var format_1 = format;
var DATE_PIPE_CONFIGURATION_TOKEN = new InjectionToken('date pipe configuration');
// default constants
var INITIAL_DEFAULT_DATE_FORMAT = 'MMMM Do, YYYY';
var DEFAULT_DATE_DISTANCE_INCLUDES_SECONDS = false;
var DEFAULT_AGO_PIPE_OPTIONS = {
    refreshRate: 15000,
    prefix: '',
    suffix: ' ago',
    includeSeconds: false
};
var DatePipeManager = /** @class */ (function () {
    /**
     * @param {?} userProvidedConfig
     */
    function DatePipeManager(userProvidedConfig) {
        this.includeSeconds = DEFAULT_DATE_DISTANCE_INCLUDES_SECONDS;
        this.agoPipeOptions = Object.assign({}, DEFAULT_AGO_PIPE_OPTIONS);
        // set default date string
        if (userProvidedConfig && userProvidedConfig.defaultDateFormat) {
            this.initializeDefaultDateFormat(userProvidedConfig.defaultDateFormat);
        }
        else {
            this.initializeDefaultDateFormat(INITIAL_DEFAULT_DATE_FORMAT);
        }
        // set default whether distance includes seconds
        if (userProvidedConfig && userProvidedConfig.dateDistanceIncludesSeconds
            && userProvidedConfig.dateDistanceIncludesSeconds === true) {
            this.includeSeconds = userProvidedConfig.dateDistanceIncludesSeconds;
        }
        else if (userProvidedConfig && typeof userProvidedConfig.dateDistanceIncludesSeconds === 'boolean'
            && userProvidedConfig.dateDistanceIncludesSeconds === false) {
            this.includeSeconds = false;
        }
        // set ago pipe defaults
        if (userProvidedConfig && userProvidedConfig.agoPipeOptions) {
            this.agoPipeOptions = Object.assign({}, this.agoPipeOptions, userProvidedConfig.agoPipeOptions);
            this.optionsToRevertTo = Object.assign({}, this.agoPipeOptions);
        }
    }
    /**
     * @param {?} defaultFormat
     * @return {?}
     */
    DatePipeManager.prototype.initializeDefaultDateFormat = function (defaultFormat) {
        this.setDefaultFormat(defaultFormat);
        this.formatToRevertTo = defaultFormat;
    };
    /**
     * @param {?=} overrideFormat
     * @return {?}
     */
    DatePipeManager.prototype.getDefaultFormat = function (overrideFormat) {
        if (overrideFormat) {
            return overrideFormat;
        }
        else {
            return this.dateFormat;
        }
    };
    /**
     * @param {?} newFormat
     * @return {?}
     */
    DatePipeManager.prototype.setDefaultFormat = function (newFormat) {
        this.dateFormat = newFormat;
    };
    /**
     * @return {?}
     */
    DatePipeManager.prototype.resetDefaultFormat = function () {
        this.dateFormat = this.formatToRevertTo;
    };
    /**
     * @return {?}
     */
    DatePipeManager.prototype.includeSecondsInDistance = function () {
        this.includeSeconds = true;
    };
    /**
     * @return {?}
     */
    DatePipeManager.prototype.doNotIncludeSecondsInDistance = function () {
        this.includeSeconds = false;
    };
    /**
     * @return {?}
     */
    DatePipeManager.prototype.secondsIncludedInDistance = function () {
        return this.includeSeconds;
    };
    /**
     * @param {?} options
     * @return {?}
     */
    DatePipeManager.prototype.setAgoPipeOptions = function (options) {
        this.agoPipeOptions = Object.assign({}, this.agoPipeOptions, options);
    };
    /**
     * @return {?}
     */
    DatePipeManager.prototype.getAgoPipeOptions = function () {
        return this.agoPipeOptions;
    };
    /**
     * @return {?}
     */
    DatePipeManager.prototype.resetAgoPipeOptions = function () {
        this.agoPipeOptions = Object.assign({}, this.optionsToRevertTo);
    };
    return DatePipeManager;
}());
DatePipeManager.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
DatePipeManager.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: Inject, args: [DATE_PIPE_CONFIGURATION_TOKEN,] },] },
]; };
function declension(scheme, count) {
    // scheme for count=1 exists
    if (scheme.one !== undefined && count === 1) {
        return scheme.one;
    }
    var rem10 = count % 10;
    var rem100 = count % 100;
    // 1, 21, 31, ...
    if (rem10 === 1 && rem100 !== 11) {
        return scheme.singularNominative.replace('{{count}}', count);
        // 2, 3, 4, 22, 23, 24, 32 ...
    }
    else if ((rem10 >= 2 && rem10 <= 4) && (rem100 < 10 || rem100 > 20)) {
        return scheme.singularGenitive.replace('{{count}}', count);
        // 5, 6, 7, 8, 9, 10, 11, ...
    }
    else {
        return scheme.pluralGenitive.replace('{{count}}', count);
    }
}
function buildLocalizeTokenFn(scheme) {
    return function (count, options) {
        if (options.addSuffix) {
            if (options.comparison > 0) {
                if (scheme.future) {
                    return declension(scheme.future, count);
                }
                else {
                    return 'через ' + declension(scheme.regular, count);
                }
            }
            else {
                if (scheme.past) {
                    return declension(scheme.past, count);
                }
                else {
                    return declension(scheme.regular, count) + ' назад';
                }
            }
        }
        else {
            return declension(scheme.regular, count);
        }
    };
}
function buildDistanceInWordsLocale$2() {
    var distanceInWordsLocale = {
        lessThanXSeconds: buildLocalizeTokenFn({
            regular: {
                one: 'меньше секунды',
                singularNominative: 'меньше {{count}} секунды',
                singularGenitive: 'меньше {{count}} секунд',
                pluralGenitive: 'меньше {{count}} секунд'
            },
            future: {
                one: 'меньше, чем через секунду',
                singularNominative: 'меньше, чем через {{count}} секунду',
                singularGenitive: 'меньше, чем через {{count}} секунды',
                pluralGenitive: 'меньше, чем через {{count}} секунд'
            }
        }),
        xSeconds: buildLocalizeTokenFn({
            regular: {
                singularNominative: '{{count}} секунда',
                singularGenitive: '{{count}} секунды',
                pluralGenitive: '{{count}} секунд'
            },
            past: {
                singularNominative: '{{count}} секунду назад',
                singularGenitive: '{{count}} секунды назад',
                pluralGenitive: '{{count}} секунд назад'
            },
            future: {
                singularNominative: 'через {{count}} секунду',
                singularGenitive: 'через {{count}} секунды',
                pluralGenitive: 'через {{count}} секунд'
            }
        }),
        halfAMinute: function (_, options) {
            if (options.addSuffix) {
                if (options.comparison > 0) {
                    return 'через полминуты';
                }
                else {
                    return 'полминуты назад';
                }
            }
            return 'полминуты';
        },
        lessThanXMinutes: buildLocalizeTokenFn({
            regular: {
                one: 'меньше минуты',
                singularNominative: 'меньше {{count}} минуты',
                singularGenitive: 'меньше {{count}} минут',
                pluralGenitive: 'меньше {{count}} минут'
            },
            future: {
                one: 'меньше, чем через минуту',
                singularNominative: 'меньше, чем через {{count}} минуту',
                singularGenitive: 'меньше, чем через {{count}} минуты',
                pluralGenitive: 'меньше, чем через {{count}} минут'
            }
        }),
        xMinutes: buildLocalizeTokenFn({
            regular: {
                singularNominative: '{{count}} минута',
                singularGenitive: '{{count}} минуты',
                pluralGenitive: '{{count}} минут'
            },
            past: {
                singularNominative: '{{count}} минуту назад',
                singularGenitive: '{{count}} минуты назад',
                pluralGenitive: '{{count}} минут назад'
            },
            future: {
                singularNominative: 'через {{count}} минуту',
                singularGenitive: 'через {{count}} минуты',
                pluralGenitive: 'через {{count}} минут'
            }
        }),
        aboutXHours: buildLocalizeTokenFn({
            regular: {
                singularNominative: 'около {{count}} часа',
                singularGenitive: 'около {{count}} часов',
                pluralGenitive: 'около {{count}} часов'
            },
            future: {
                singularNominative: 'приблизительно через {{count}} час',
                singularGenitive: 'приблизительно через {{count}} часа',
                pluralGenitive: 'приблизительно через {{count}} часов'
            }
        }),
        xHours: buildLocalizeTokenFn({
            regular: {
                singularNominative: '{{count}} час',
                singularGenitive: '{{count}} часа',
                pluralGenitive: '{{count}} часов'
            }
        }),
        xDays: buildLocalizeTokenFn({
            regular: {
                singularNominative: '{{count}} день',
                singularGenitive: '{{count}} дня',
                pluralGenitive: '{{count}} дней'
            }
        }),
        aboutXMonths: buildLocalizeTokenFn({
            regular: {
                singularNominative: 'около {{count}} месяца',
                singularGenitive: 'около {{count}} месяцев',
                pluralGenitive: 'около {{count}} месяцев'
            },
            future: {
                singularNominative: 'приблизительно через {{count}} месяц',
                singularGenitive: 'приблизительно через {{count}} месяца',
                pluralGenitive: 'приблизительно через {{count}} месяцев'
            }
        }),
        xMonths: buildLocalizeTokenFn({
            regular: {
                singularNominative: '{{count}} месяц',
                singularGenitive: '{{count}} месяца',
                pluralGenitive: '{{count}} месяцев'
            }
        }),
        aboutXYears: buildLocalizeTokenFn({
            regular: {
                singularNominative: 'около {{count}} года',
                singularGenitive: 'около {{count}} лет',
                pluralGenitive: 'около {{count}} лет'
            },
            future: {
                singularNominative: 'приблизительно через {{count}} год',
                singularGenitive: 'приблизительно через {{count}} года',
                pluralGenitive: 'приблизительно через {{count}} лет'
            }
        }),
        xYears: buildLocalizeTokenFn({
            regular: {
                singularNominative: '{{count}} год',
                singularGenitive: '{{count}} года',
                pluralGenitive: '{{count}} лет'
            }
        }),
        overXYears: buildLocalizeTokenFn({
            regular: {
                singularNominative: 'больше {{count}} года',
                singularGenitive: 'больше {{count}} лет',
                pluralGenitive: 'больше {{count}} лет'
            },
            future: {
                singularNominative: 'больше, чем через {{count}} год',
                singularGenitive: 'больше, чем через {{count}} года',
                pluralGenitive: 'больше, чем через {{count}} лет'
            }
        }),
        almostXYears: buildLocalizeTokenFn({
            regular: {
                singularNominative: 'почти {{count}} год',
                singularGenitive: 'почти {{count}} года',
                pluralGenitive: 'почти {{count}} лет'
            },
            future: {
                singularNominative: 'почти через {{count}} год',
                singularGenitive: 'почти через {{count}} года',
                pluralGenitive: 'почти через {{count}} лет'
            }
        })
    };
    function localize(token, count, options) {
        options = options || {};
        return distanceInWordsLocale[token](count, options);
    }
    return {
        localize: localize
    };
}
var build_distance_in_words_locale$2 = buildDistanceInWordsLocale$2;
function buildFormatLocale$2() {
    // http://new.gramota.ru/spravka/buro/search-answer?s=242637
    var monthsShort = ['янв.', 'фев.', 'март', 'апр.', 'май', 'июнь', 'июль', 'авг.', 'сент.', 'окт.', 'нояб.', 'дек.'];
    var monthsFull = ['январь', 'февраль', 'март', 'апрель', 'май', 'июнь', 'июль', 'август', 'сентябрь', 'октябрь', 'ноябрь', 'декабрь'];
    var monthsGenitive = ['января', 'февраля', 'марта', 'апреля', 'мая', 'июня', 'июля', 'августа', 'сентября', 'октября', 'ноября', 'декабря'];
    var weekdays2char = ['вс', 'пн', 'вт', 'ср', 'чт', 'пт', 'сб'];
    var weekdays3char = ['вск', 'пнд', 'втр', 'срд', 'чтв', 'птн', 'суб'];
    var weekdaysFull = ['воскресенье', 'понедельник', 'вторник', 'среда', 'четверг', 'пятница', 'суббота'];
    var meridiem = ['ночи', 'утра', 'дня', 'вечера'];
    var formatters = {
        // Month: янв., фев., ..., дек.
        'MMM': function (date) {
            return monthsShort[date.getMonth()];
        },
        // Month: январь, февраль, ..., декабрь
        'MMMM': function (date) {
            return monthsFull[date.getMonth()];
        },
        // Day of week: вс, пн, ..., сб
        'dd': function (date) {
            return weekdays2char[date.getDay()];
        },
        // Day of week: вск, пнд, ..., суб
        'ddd': function (date) {
            return weekdays3char[date.getDay()];
        },
        // Day of week: воскресенье, понедельник, ..., суббота
        'dddd': function (date) {
            return weekdaysFull[date.getDay()];
        },
        // Time of day: ночи, утра, дня, вечера
        'A': function (date) {
            var hours = date.getHours();
            if (hours >= 17) {
                return meridiem[3];
            }
            else if (hours >= 12) {
                return meridiem[2];
            }
            else if (hours >= 4) {
                return meridiem[1];
            }
            else {
                return meridiem[0];
            }
        },
        'Do': function (date, formatters) {
            return formatters.D(date) + '-е';
        },
        'Wo': function (date, formatters) {
            return formatters.W(date) + '-я';
        }
    };
    formatters.a = formatters.A;
    formatters.aa = formatters.A;
    // Generate ordinal version of formatters: M -> Mo, DDD -> DDDo, etc.
    var ordinalFormatters = ['M', 'DDD', 'd', 'Q'];
    ordinalFormatters.forEach(function (formatterToken) {
        formatters[formatterToken + 'o'] = function (date, formatters) {
            return formatters[formatterToken](date) + '-й';
        };
    });
    // Generate formatters like 'D MMMM',
    // where month is in the genitive case: января, февраля, ..., декабря
    var monthsGenitiveFormatters = ['D', 'Do', 'DD'];
    monthsGenitiveFormatters.forEach(function (formatterToken) {
        formatters[formatterToken + ' MMMM'] = function (date, commonFormatters) {
            var formatter = formatters[formatterToken] || commonFormatters[formatterToken];
            return formatter(date, commonFormatters) + ' ' + monthsGenitive[date.getMonth()];
        };
    });
    return {
        formatters: formatters,
        formattingTokensRegExp: build_formatting_tokens_reg_exp(formatters)
    };
}
var build_format_locale$2 = buildFormatLocale$2;
/**
 * @category Locales
 * @summary Russian locale.
 */
var ru = {
    distanceInWords: build_distance_in_words_locale$2(),
    format: build_format_locale$2()
};
var ru$2 = Object.freeze({
    default: ru,
    __moduleExports: ru
});
function buildDistanceInWordsLocale$4() {
    var distanceInWordsLocale = {
        lessThanXSeconds: {
            one: 'malpli ol sekundo',
            other: 'malpli ol {{count}} sekundoj'
        },
        xSeconds: {
            one: '1 sekundo',
            other: '{{count}} sekundoj'
        },
        halfAMinute: 'duonminuto',
        lessThanXMinutes: {
            one: 'malpli ol minuto',
            other: 'malpli ol {{count}} minutoj'
        },
        xMinutes: {
            one: '1 minuto',
            other: '{{count}} minutoj'
        },
        aboutXHours: {
            one: 'proksimume 1 horo',
            other: 'proksimume {{count}} horoj'
        },
        xHours: {
            one: '1 horo',
            other: '{{count}} horoj'
        },
        xDays: {
            one: '1 tago',
            other: '{{count}} tagoj'
        },
        aboutXMonths: {
            one: 'proksimume 1 monato',
            other: 'proksimume {{count}} monatoj'
        },
        xMonths: {
            one: '1 monato',
            other: '{{count}} monatoj'
        },
        aboutXYears: {
            one: 'proksimume 1 jaro',
            other: 'proksimume {{count}} jaroj'
        },
        xYears: {
            one: '1 jaro',
            other: '{{count}} jaroj'
        },
        overXYears: {
            one: 'pli ol 1 jaro',
            other: 'pli ol {{count}} jaroj'
        },
        almostXYears: {
            one: 'preskaŭ 1 jaro',
            other: 'preskaŭ {{count}} jaroj'
        }
    };
    function localize(token, count, options) {
        options = options || {};
        var result;
        if (typeof distanceInWordsLocale[token] === 'string') {
            result = distanceInWordsLocale[token];
        }
        else if (count === 1) {
            result = distanceInWordsLocale[token].one;
        }
        else {
            result = distanceInWordsLocale[token].other.replace('{{count}}', count);
        }
        if (options.addSuffix) {
            if (options.comparison > 0) {
                return 'post ' + result;
            }
            else {
                return 'antaŭ ' + result;
            }
        }
        return result;
    }
    return {
        localize: localize
    };
}
var build_distance_in_words_locale$4 = buildDistanceInWordsLocale$4;
function buildFormatLocale$4() {
    var months3char = ['jan', 'feb', 'mar', 'apr', 'maj', 'jun', 'jul', 'aŭg', 'sep', 'okt', 'nov', 'dec'];
    var monthsFull = ['januaro', 'februaro', 'marto', 'aprilo', 'majo', 'junio', 'julio', 'aŭgusto', 'septembro', 'oktobro', 'novembro', 'decembro'];
    var weekdays2char = ['di', 'lu', 'ma', 'me', 'ĵa', 've', 'sa'];
    var weekdays3char = ['dim', 'lun', 'mar', 'mer', 'ĵaŭ', 'ven', 'sab'];
    var weekdaysFull = ['dimanĉo', 'lundo', 'mardo', 'merkredo', 'ĵaŭdo', 'vendredo', 'sabato'];
    var meridiemUppercase = ['A.T.M.', 'P.T.M.'];
    var meridiemLowercase = ['a.t.m.', 'p.t.m.'];
    var meridiemFull = ['antaŭtagmeze', 'posttagmeze'];
    var formatters = {
        // Month: jan, feb, ..., deс
        'MMM': function (date) {
            return months3char[date.getMonth()];
        },
        // Month: januaro, februaro, ..., decembro
        'MMMM': function (date) {
            return monthsFull[date.getMonth()];
        },
        // Day of week: di, lu, ..., sa
        'dd': function (date) {
            return weekdays2char[date.getDay()];
        },
        // Day of week: dim, lun, ..., sab
        'ddd': function (date) {
            return weekdays3char[date.getDay()];
        },
        // Day of week: dimanĉo, lundo, ..., sabato
        'dddd': function (date) {
            return weekdaysFull[date.getDay()];
        },
        // A.T.M., P.T.M.
        'A': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemUppercase[1] : meridiemUppercase[0];
        },
        // a.t.m., p.t.m.
        'a': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemLowercase[1] : meridiemLowercase[0];
        },
        // antaŭtagmeze, posttagmeze
        'aa': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemFull[1] : meridiemFull[0];
        }
    };
    // Generate ordinal version of formatters: M -> Mo, D -> Do, etc.
    var ordinalFormatters = ['M', 'D', 'DDD', 'd', 'Q', 'W'];
    ordinalFormatters.forEach(function (formatterToken) {
        formatters[formatterToken + 'o'] = function (date, formatters) {
            return formatters[formatterToken](date) + '-a';
        };
    });
    return {
        formatters: formatters,
        formattingTokensRegExp: build_formatting_tokens_reg_exp(formatters)
    };
}
var build_format_locale$4 = buildFormatLocale$4;
/**
 * @category Locales
 * @summary Esperanto locale.
 */
var eo = {
    distanceInWords: build_distance_in_words_locale$4(),
    format: build_format_locale$4()
};
var eo$2 = Object.freeze({
    default: eo,
    __moduleExports: eo
});
function buildDistanceInWordsLocale$6() {
    var distanceInWordsLocale = {
        lessThanXSeconds: {
            one: '不到 1 秒',
            other: '不到 {{count}} 秒'
        },
        xSeconds: {
            one: '1 秒',
            other: '{{count}} 秒'
        },
        halfAMinute: '半分钟',
        lessThanXMinutes: {
            one: '不到 1 分钟',
            other: '不到 {{count}} 分钟'
        },
        xMinutes: {
            one: '1 分钟',
            other: '{{count}} 分钟'
        },
        xHours: {
            one: '1 小时',
            other: '{{count}} 小时'
        },
        aboutXHours: {
            one: '大约 1 小时',
            other: '大约 {{count}} 小时'
        },
        xDays: {
            one: '1 天',
            other: '{{count}} 天'
        },
        aboutXMonths: {
            one: '大约 1 个月',
            other: '大约 {{count}} 个月'
        },
        xMonths: {
            one: '1 个月',
            other: '{{count}} 个月'
        },
        aboutXYears: {
            one: '大约 1 年',
            other: '大约 {{count}} 年'
        },
        xYears: {
            one: '1 年',
            other: '{{count}} 年'
        },
        overXYears: {
            one: '超过 1 年',
            other: '超过 {{count}} 年'
        },
        almostXYears: {
            one: '将近 1 年',
            other: '将近 {{count}} 年'
        }
    };
    function localize(token, count, options) {
        options = options || {};
        var result;
        if (typeof distanceInWordsLocale[token] === 'string') {
            result = distanceInWordsLocale[token];
        }
        else if (count === 1) {
            result = distanceInWordsLocale[token].one;
        }
        else {
            result = distanceInWordsLocale[token].other.replace('{{count}}', count);
        }
        if (options.addSuffix) {
            if (options.comparison > 0) {
                return result + '内';
            }
            else {
                return result + '前';
            }
        }
        return result;
    }
    return {
        localize: localize
    };
}
var build_distance_in_words_locale$6 = buildDistanceInWordsLocale$6;
function buildFormatLocale$6() {
    var months3char = ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'];
    var monthsFull = ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'];
    var weekdays2char = ['日', '一', '二', '三', '四', '五', '六'];
    var weekdays3char = ['周日', '周一', '周二', '周三', '周四', '周五', '周六'];
    var weekdaysFull = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];
    var meridiemFull = ['上午', '下午'];
    var formatters = {
        // Month: Jan, Feb, ..., Dec
        'MMM': function (date) {
            return months3char[date.getMonth()];
        },
        // Month: January, February, ..., December
        'MMMM': function (date) {
            return monthsFull[date.getMonth()];
        },
        // Day of week: Su, Mo, ..., Sa
        'dd': function (date) {
            return weekdays2char[date.getDay()];
        },
        // Day of week: Sun, Mon, ..., Sat
        'ddd': function (date) {
            return weekdays3char[date.getDay()];
        },
        // Day of week: Sunday, Monday, ..., Saturday
        'dddd': function (date) {
            return weekdaysFull[date.getDay()];
        }
    };
    // AM, PM / am, pm / a.m., p.m. all translates to 上午, 下午
    formatters.a = formatters.aa = formatters.A = function (date) {
        return (date.getHours() / 12) >= 1 ? meridiemFull[1] : meridiemFull[0];
    };
    // Generate ordinal version of formatters: M -> Mo, D -> Do, etc.
    var ordinalFormatters = ['M', 'D', 'DDD', 'd', 'Q', 'W'];
    ordinalFormatters.forEach(function (formatterToken) {
        formatters[formatterToken + 'o'] = function (date, formatters) {
            return ordinal$1(formatters[formatterToken](date));
        };
    });
    return {
        formatters: formatters,
        formattingTokensRegExp: build_formatting_tokens_reg_exp(formatters)
    };
}
function ordinal$1(number) {
    return number.toString();
}
var build_format_locale$6 = buildFormatLocale$6;
/**
 * @category Locales
 * @summary Chinese Simplified locale.
 * @author Changyu Geng [@KingMario]{@link https://github.com/KingMario}
 * @author Song Shuoyun [@fnlctrl]{@link https://github.com/fnlctrl}
 */
var zh_cn = {
    distanceInWords: build_distance_in_words_locale$6(),
    format: build_format_locale$6()
};
var zh_cn$2 = Object.freeze({
    default: zh_cn,
    __moduleExports: zh_cn
});
function buildDistanceInWordsLocale$8() {
    var distanceInWordsLocale = {
        lessThanXSeconds: {
            standalone: {
                one: 'weniger als eine Sekunde',
                other: 'weniger als {{count}} Sekunden'
            },
            withPreposition: {
                one: 'weniger als einer Sekunde',
                other: 'weniger als {{count}} Sekunden'
            }
        },
        xSeconds: {
            standalone: {
                one: 'eine Sekunde',
                other: '{{count}} Sekunden'
            },
            withPreposition: {
                one: 'einer Sekunde',
                other: '{{count}} Sekunden'
            }
        },
        halfAMinute: {
            standalone: 'eine halbe Minute',
            withPreposition: 'einer halben Minute'
        },
        lessThanXMinutes: {
            standalone: {
                one: 'weniger als eine Minute',
                other: 'weniger als {{count}} Minuten'
            },
            withPreposition: {
                one: 'weniger als einer Minute',
                other: 'weniger als {{count}} Minuten'
            }
        },
        xMinutes: {
            standalone: {
                one: 'eine Minute',
                other: '{{count}} Minuten'
            },
            withPreposition: {
                one: 'einer Minute',
                other: '{{count}} Minuten'
            }
        },
        aboutXHours: {
            standalone: {
                one: 'etwa eine Stunde',
                other: 'etwa {{count}} Stunden'
            },
            withPreposition: {
                one: 'etwa einer Stunde',
                other: 'etwa {{count}} Stunden'
            }
        },
        xHours: {
            standalone: {
                one: 'eine Stunde',
                other: '{{count}} Stunden'
            },
            withPreposition: {
                one: 'einer Stunde',
                other: '{{count}} Stunden'
            }
        },
        xDays: {
            standalone: {
                one: 'ein Tag',
                other: '{{count}} Tage'
            },
            withPreposition: {
                one: 'einem Tag',
                other: '{{count}} Tagen'
            }
        },
        aboutXMonths: {
            standalone: {
                one: 'etwa ein Monat',
                other: 'etwa {{count}} Monate'
            },
            withPreposition: {
                one: 'etwa einem Monat',
                other: 'etwa {{count}} Monaten'
            }
        },
        xMonths: {
            standalone: {
                one: 'ein Monat',
                other: '{{count}} Monate'
            },
            withPreposition: {
                one: 'einem Monat',
                other: '{{count}} Monaten'
            }
        },
        aboutXYears: {
            standalone: {
                one: 'etwa ein Jahr',
                other: 'etwa {{count}} Jahre'
            },
            withPreposition: {
                one: 'etwa einem Jahr',
                other: 'etwa {{count}} Jahren'
            }
        },
        xYears: {
            standalone: {
                one: 'ein Jahr',
                other: '{{count}} Jahre'
            },
            withPreposition: {
                one: 'einem Jahr',
                other: '{{count}} Jahren'
            }
        },
        overXYears: {
            standalone: {
                one: 'mehr als ein Jahr',
                other: 'mehr als {{count}} Jahre'
            },
            withPreposition: {
                one: 'mehr als einem Jahr',
                other: 'mehr als {{count}} Jahren'
            }
        },
        almostXYears: {
            standalone: {
                one: 'fast ein Jahr',
                other: 'fast {{count}} Jahre'
            },
            withPreposition: {
                one: 'fast einem Jahr',
                other: 'fast {{count}} Jahren'
            }
        }
    };
    function localize(token, count, options) {
        options = options || {};
        var usageGroup = options.addSuffix
            ? distanceInWordsLocale[token].withPreposition
            : distanceInWordsLocale[token].standalone;
        var result;
        if (typeof usageGroup === 'string') {
            result = usageGroup;
        }
        else if (count === 1) {
            result = usageGroup.one;
        }
        else {
            result = usageGroup.other.replace('{{count}}', count);
        }
        if (options.addSuffix) {
            if (options.comparison > 0) {
                return 'in ' + result;
            }
            else {
                return 'vor ' + result;
            }
        }
        return result;
    }
    return {
        localize: localize
    };
}
var build_distance_in_words_locale$8 = buildDistanceInWordsLocale$8;
function buildFormatLocale$8() {
    // Note: in German, the names of days of the week and months are capitalized.
    // If you are making a new locale based on this one, check if the same is true for the language you're working on.
    // Generally, formatted dates should look like they are in the middle of a sentence,
    // e.g. in Spanish language the weekdays and months should be in the lowercase.
    var months3char = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'];
    var monthsFull = ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'];
    var weekdays2char = ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'];
    var weekdays3char = ['Son', 'Mon', 'Die', 'Mit', 'Don', 'Fre', 'Sam'];
    var weekdaysFull = ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'];
    var meridiemUppercase = ['AM', 'PM'];
    var meridiemLowercase = ['am', 'pm'];
    var meridiemFull = ['a.m.', 'p.m.'];
    var formatters = {
        // Month: Jan, Feb, ..., Dec
        'MMM': function (date) {
            return months3char[date.getMonth()];
        },
        // Month: January, February, ..., December
        'MMMM': function (date) {
            return monthsFull[date.getMonth()];
        },
        // Day of week: Su, Mo, ..., Sa
        'dd': function (date) {
            return weekdays2char[date.getDay()];
        },
        // Day of week: Sun, Mon, ..., Sat
        'ddd': function (date) {
            return weekdays3char[date.getDay()];
        },
        // Day of week: Sunday, Monday, ..., Saturday
        'dddd': function (date) {
            return weekdaysFull[date.getDay()];
        },
        // AM, PM
        'A': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemUppercase[1] : meridiemUppercase[0];
        },
        // am, pm
        'a': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemLowercase[1] : meridiemLowercase[0];
        },
        // a.m., p.m.
        'aa': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemFull[1] : meridiemFull[0];
        }
    };
    // Generate ordinal version of formatters: M -> Mo, D -> Do, etc.
    var ordinalFormatters = ['M', 'D', 'DDD', 'd', 'Q', 'W'];
    ordinalFormatters.forEach(function (formatterToken) {
        formatters[formatterToken + 'o'] = function (date, formatters) {
            return ordinal$2(formatters[formatterToken](date));
        };
    });
    return {
        formatters: formatters,
        formattingTokensRegExp: build_formatting_tokens_reg_exp(formatters)
    };
}
function ordinal$2(number) {
    return number + '.';
}
var build_format_locale$8 = buildFormatLocale$8;
/**
 * @category Locales
 * @summary German locale.
 * @author Thomas Eilmsteiner [@DeMuu]{@link https://github.com/DeMuu}
 * @author Asia [@asia-t]{@link https://github.com/asia-t}
 */
var de = {
    distanceInWords: build_distance_in_words_locale$8(),
    format: build_format_locale$8()
};
var de$2 = Object.freeze({
    default: de,
    __moduleExports: de
});
function buildDistanceInWordsLocale$10() {
    var distanceInWordsLocale = {
        lessThanXSeconds: {
            one: '1秒以下',
            other: '{{count}}秒以下'
        },
        xSeconds: {
            one: '1秒',
            other: '{{count}}秒'
        },
        halfAMinute: '30秒ぐらい',
        lessThanXMinutes: {
            one: '1分以下',
            other: '{{count}}分以下'
        },
        xMinutes: {
            one: '1分',
            other: '{{count}}分'
        },
        aboutXHours: {
            one: '1時間ぐらい',
            other: '{{count}}時間ぐらい'
        },
        xHours: {
            one: '1時間',
            other: '{{count}}時間'
        },
        xDays: {
            one: '1日',
            other: '{{count}}日'
        },
        aboutXMonths: {
            one: '1ヶ月ぐらい',
            other: '{{count}}ヶ月ぐらい'
        },
        xMonths: {
            one: '1ヶ月',
            other: '{{count}}ヶ月'
        },
        aboutXYears: {
            one: '1年ぐらい',
            other: '{{count}}年ぐらい'
        },
        xYears: {
            one: '1年',
            other: '{{count}}年'
        },
        overXYears: {
            one: '1年以上',
            other: '{{count}}年以上'
        },
        almostXYears: {
            one: '1年以下',
            other: '{{count}}年以下'
        }
    };
    function localize(token, count, options) {
        options = options || {};
        var result;
        if (typeof distanceInWordsLocale[token] === 'string') {
            result = distanceInWordsLocale[token];
        }
        else if (count === 1) {
            result = distanceInWordsLocale[token].one;
        }
        else {
            result = distanceInWordsLocale[token].other.replace('{{count}}', count);
        }
        if (options.addSuffix) {
            if (options.comparison > 0) {
                return result + '後';
            }
            else {
                return result + '前';
            }
        }
        return result;
    }
    return {
        localize: localize
    };
}
var build_distance_in_words_locale$10 = buildDistanceInWordsLocale$10;
function buildFormatLocale$10() {
    var months3char = ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'];
    var monthsFull = ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'];
    var weekdays2char = ['日', '月', '火', '水', '木', '金', '土'];
    var weekdays3char = ['日曜', '月曜', '火曜', '水曜', '木曜', '金曜', '土曜'];
    var weekdaysFull = ['日曜日', '月曜日', '火曜日', '水曜日', '木曜日', '金曜日', '土曜日'];
    var meridiemUppercase = ['午前', '午後'];
    var meridiemLowercase = ['午前', '午後'];
    var meridiemFull = ['午前', '午後'];
    var formatters = {
        // Month: Jan, Feb, ..., Dec
        'MMM': function (date) {
            return months3char[date.getMonth()];
        },
        // Month: January, February, ..., December
        'MMMM': function (date) {
            return monthsFull[date.getMonth()];
        },
        // Day of week: Su, Mo, ..., Sa
        'dd': function (date) {
            return weekdays2char[date.getDay()];
        },
        // Day of week: Sun, Mon, ..., Sat
        'ddd': function (date) {
            return weekdays3char[date.getDay()];
        },
        // Day of week: Sunday, Monday, ..., Saturday
        'dddd': function (date) {
            return weekdaysFull[date.getDay()];
        },
        // AM, PM
        'A': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemUppercase[1] : meridiemUppercase[0];
        },
        // am, pm
        'a': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemLowercase[1] : meridiemLowercase[0];
        },
        // a.m., p.m.
        'aa': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemFull[1] : meridiemFull[0];
        }
    };
    // Generate ordinal version of formatters: M -> Mo, D -> Do, etc.
    var ordinalFormatters = ['M', 'D', 'DDD', 'd', 'Q', 'W'];
    ordinalFormatters.forEach(function (formatterToken) {
        formatters[formatterToken + 'o'] = function (date, formatters) {
            return ordinal$3(formatters[formatterToken](date));
        };
    });
    return {
        formatters: formatters,
        formattingTokensRegExp: build_formatting_tokens_reg_exp(formatters)
    };
}
function ordinal$3(number) {
    return number + '日';
}
var build_format_locale$10 = buildFormatLocale$10;
/**
 * @category Locales
 * @summary Japanese locale.
 * @author Thomas Eilmsteiner [@DeMuu]{@link https://github.com/DeMuu}
 * @author Yamagishi Kazutoshi [@ykzts]{@link https://github.com/ykzts}
 */
var ja = {
    distanceInWords: build_distance_in_words_locale$10(),
    format: build_format_locale$10()
};
var ja$2 = Object.freeze({
    default: ja,
    __moduleExports: ja
});
function buildDistanceInWordsLocale$12() {
    var distanceInWordsLocale = {
        lessThanXSeconds: {
            one: 'menos de un segundo',
            other: 'menos de {{count}} segundos'
        },
        xSeconds: {
            one: '1 segundo',
            other: '{{count}} segundos'
        },
        halfAMinute: 'medio minuto',
        lessThanXMinutes: {
            one: 'menos de un minuto',
            other: 'menos de {{count}} minutos'
        },
        xMinutes: {
            one: '1 minuto',
            other: '{{count}} minutos'
        },
        aboutXHours: {
            one: 'alrededor de 1 hora',
            other: 'alrededor de {{count}} horas'
        },
        xHours: {
            one: '1 hora',
            other: '{{count}} horas'
        },
        xDays: {
            one: '1 día',
            other: '{{count}} días'
        },
        aboutXMonths: {
            one: 'alrededor de 1 mes',
            other: 'alrededor de {{count}} meses'
        },
        xMonths: {
            one: '1 mes',
            other: '{{count}} meses'
        },
        aboutXYears: {
            one: 'alrededor de 1 año',
            other: 'alrededor de {{count}} años'
        },
        xYears: {
            one: '1 año',
            other: '{{count}} años'
        },
        overXYears: {
            one: 'más de 1 año',
            other: 'más de {{count}} años'
        },
        almostXYears: {
            one: 'casi 1 año',
            other: 'casi {{count}} años'
        }
    };
    function localize(token, count, options) {
        options = options || {};
        var result;
        if (typeof distanceInWordsLocale[token] === 'string') {
            result = distanceInWordsLocale[token];
        }
        else if (count === 1) {
            result = distanceInWordsLocale[token].one;
        }
        else {
            result = distanceInWordsLocale[token].other.replace('{{count}}', count);
        }
        if (options.addSuffix) {
            if (options.comparison > 0) {
                return 'en ' + result;
            }
            else {
                return 'hace ' + result;
            }
        }
        return result;
    }
    return {
        localize: localize
    };
}
var build_distance_in_words_locale$12 = buildDistanceInWordsLocale$12;
function buildFormatLocale$12() {
    var months3char = ['ene', 'feb', 'mar', 'abr', 'may', 'jun', 'jul', 'ago', 'sep', 'oct', 'nov', 'dic'];
    var monthsFull = ['enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio', 'julio', 'agosto', 'septiembre', 'octubre', 'noviembre', 'diciembre'];
    var weekdays2char = ['do', 'lu', 'ma', 'mi', 'ju', 'vi', 'sa'];
    var weekdays3char = ['dom', 'lun', 'mar', 'mié', 'jue', 'vie', 'sáb'];
    var weekdaysFull = ['domingo', 'lunes', 'martes', 'miércoles', 'jueves', 'viernes', 'sábado'];
    var meridiemUppercase = ['AM', 'PM'];
    var meridiemLowercase = ['am', 'pm'];
    var meridiemFull = ['a.m.', 'p.m.'];
    var formatters = {
        // Month: Jan, Feb, ..., Dec
        'MMM': function (date) {
            return months3char[date.getMonth()];
        },
        // Month: January, February, ..., December
        'MMMM': function (date) {
            return monthsFull[date.getMonth()];
        },
        // Day of week: Su, Mo, ..., Sa
        'dd': function (date) {
            return weekdays2char[date.getDay()];
        },
        // Day of week: Sun, Mon, ..., Sat
        'ddd': function (date) {
            return weekdays3char[date.getDay()];
        },
        // Day of week: Sunday, Monday, ..., Saturday
        'dddd': function (date) {
            return weekdaysFull[date.getDay()];
        },
        // AM, PM
        'A': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemUppercase[1] : meridiemUppercase[0];
        },
        // am, pm
        'a': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemLowercase[1] : meridiemLowercase[0];
        },
        // a.m., p.m.
        'aa': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemFull[1] : meridiemFull[0];
        }
    };
    // Generate ordinal version of formatters: M -> Mo, D -> Do, etc.
    var ordinalFormatters = ['M', 'D', 'DDD', 'd', 'Q', 'W'];
    ordinalFormatters.forEach(function (formatterToken) {
        formatters[formatterToken + 'o'] = function (date, formatters) {
            return ordinal$4(formatters[formatterToken](date));
        };
    });
    return {
        formatters: formatters,
        formattingTokensRegExp: build_formatting_tokens_reg_exp(formatters)
    };
}
function ordinal$4(number) {
    return number + 'º';
}
var build_format_locale$12 = buildFormatLocale$12;
/**
 * @category Locales
 * @summary Spanish locale.
 * @author Juan Angosto [@juanangosto]{@link https://github.com/juanangosto}
 * @author Guillermo Grau [@guigrpa]{@link https://github.com/guigrpa}
 * @author Fernando Agüero [@fjaguero]{@link https://github.com/fjaguero}
 */
var es = {
    distanceInWords: build_distance_in_words_locale$12(),
    format: build_format_locale$12()
};
var es$2 = Object.freeze({
    default: es,
    __moduleExports: es
});
function buildDistanceInWordsLocale$14() {
    var distanceInWordsLocale = {
        lessThanXSeconds: {
            one: 'minder dan een seconde',
            other: 'minder dan {{count}} seconden'
        },
        xSeconds: {
            one: '1 seconde',
            other: '{{count}} seconden'
        },
        halfAMinute: 'een halve minuut',
        lessThanXMinutes: {
            one: 'minder dan een minuut',
            other: 'minder dan {{count}} minuten'
        },
        xMinutes: {
            one: 'een minuut',
            other: '{{count}} minuten'
        },
        aboutXHours: {
            one: 'ongeveer 1 uur',
            other: 'ongeveer {{count}} uur'
        },
        xHours: {
            one: '1 uur',
            other: '{{count}} uur'
        },
        xDays: {
            one: '1 dag',
            other: '{{count}} dagen'
        },
        aboutXMonths: {
            one: 'ongeveer 1 maand',
            other: 'ongeveer {{count}} maanden'
        },
        xMonths: {
            one: '1 maand',
            other: '{{count}} maanden'
        },
        aboutXYears: {
            one: 'ongeveer 1 jaar',
            other: 'ongeveer {{count}} jaar'
        },
        xYears: {
            one: '1 jaar',
            other: '{{count}} jaar'
        },
        overXYears: {
            one: 'meer dan 1 jaar',
            other: 'meer dan {{count}} jaar'
        },
        almostXYears: {
            one: 'bijna 1 jaar',
            other: 'bijna {{count}} jaar'
        }
    };
    function localize(token, count, options) {
        options = options || {};
        var result;
        if (typeof distanceInWordsLocale[token] === 'string') {
            result = distanceInWordsLocale[token];
        }
        else if (count === 1) {
            result = distanceInWordsLocale[token].one;
        }
        else {
            result = distanceInWordsLocale[token].other.replace('{{count}}', count);
        }
        if (options.addSuffix) {
            if (options.comparison > 0) {
                return 'over ' + result;
            }
            else {
                return result + ' geleden';
            }
        }
        return result;
    }
    return {
        localize: localize
    };
}
var build_distance_in_words_locale$14 = buildDistanceInWordsLocale$14;
function buildFormatLocale$14() {
    var months3char = ['jan', 'feb', 'mar', 'apr', 'mei', 'jun', 'jul', 'aug', 'sep', 'okt', 'nov', 'dec'];
    var monthsFull = ['januari', 'februari', 'maart', 'april', 'mei', 'juni', 'juli', 'augustus', 'september', 'oktober', 'november', 'december'];
    var weekdays2char = ['zo', 'ma', 'di', 'wo', 'do', 'vr', 'za'];
    var weekdays3char = ['zon', 'maa', 'din', 'woe', 'don', 'vri', 'zat'];
    var weekdaysFull = ['zondag', 'maandag', 'dinsdag', 'woensdag', 'donderdag', 'vrijdag', 'zaterdag'];
    var meridiemUppercase = ['AM', 'PM'];
    var meridiemLowercase = ['am', 'pm'];
    var meridiemFull = ['a.m.', 'p.m.'];
    var formatters = {
        // Month: Jan, Feb, ..., Dec
        'MMM': function (date) {
            return months3char[date.getMonth()];
        },
        // Month: January, February, ..., December
        'MMMM': function (date) {
            return monthsFull[date.getMonth()];
        },
        // Day of week: Su, Mo, ..., Sa
        'dd': function (date) {
            return weekdays2char[date.getDay()];
        },
        // Day of week: Sun, Mon, ..., Sat
        'ddd': function (date) {
            return weekdays3char[date.getDay()];
        },
        // Day of week: Sunday, Monday, ..., Saturday
        'dddd': function (date) {
            return weekdaysFull[date.getDay()];
        },
        // AM, PM
        'A': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemUppercase[1] : meridiemUppercase[0];
        },
        // am, pm
        'a': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemLowercase[1] : meridiemLowercase[0];
        },
        // a.m., p.m.
        'aa': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemFull[1] : meridiemFull[0];
        }
    };
    // Generate ordinal version of formatters: M -> Mo, D -> Do, etc.
    var ordinalFormatters = ['M', 'D', 'DDD', 'd', 'Q', 'W'];
    ordinalFormatters.forEach(function (formatterToken) {
        formatters[formatterToken + 'o'] = function (date, formatters) {
            return ordinal$5(formatters[formatterToken](date));
        };
    });
    return {
        formatters: formatters,
        formattingTokensRegExp: build_formatting_tokens_reg_exp(formatters)
    };
}
function ordinal$5(number) {
    return number + 'e';
}
var build_format_locale$14 = buildFormatLocale$14;
/**
 * @category Locales
 * @summary Dutch locale.
 * @author Jorik Tangelder [@jtangelder]{@link https://github.com/jtangelder}
 * @author Ruben Stolk [@rubenstolk]{@link https://github.com/rubenstolk}
 */
var nl = {
    distanceInWords: build_distance_in_words_locale$14(),
    format: build_format_locale$14()
};
var nl$2 = Object.freeze({
    default: nl,
    __moduleExports: nl
});
function buildDistanceInWordsLocale$16() {
    var distanceInWordsLocale = {
        lessThanXSeconds: {
            one: 'mindre enn ett sekund',
            other: 'mindre enn {{count}} sekunder'
        },
        xSeconds: {
            one: 'ett sekund',
            other: '{{count}} sekunder'
        },
        halfAMinute: 'et halvt minutt',
        lessThanXMinutes: {
            one: 'mindre enn ett minutt',
            other: 'mindre enn {{count}} minutter'
        },
        xMinutes: {
            one: 'ett minutt',
            other: '{{count}} minutter'
        },
        aboutXHours: {
            one: 'rundt en time',
            other: 'rundt {{count}} timer'
        },
        xHours: {
            one: 'en time',
            other: '{{count}} timer'
        },
        xDays: {
            one: 'en dag',
            other: '{{count}} dager'
        },
        aboutXMonths: {
            one: 'rundt en måned',
            other: 'rundt {{count}} måneder'
        },
        xMonths: {
            one: 'en måned',
            other: '{{count}} måneder'
        },
        aboutXYears: {
            one: 'rundt ett år',
            other: 'rundt {{count}} år'
        },
        xYears: {
            one: 'ett år',
            other: '{{count}} år'
        },
        overXYears: {
            one: 'over ett år',
            other: 'over {{count}} år'
        },
        almostXYears: {
            one: 'nesten ett år',
            other: 'nesten {{count}} år'
        }
    };
    function localize(token, count, options) {
        options = options || {};
        var result;
        if (typeof distanceInWordsLocale[token] === 'string') {
            result = distanceInWordsLocale[token];
        }
        else if (count === 1) {
            result = distanceInWordsLocale[token].one;
        }
        else {
            result = distanceInWordsLocale[token].other.replace('{{count}}', count);
        }
        if (options.addSuffix) {
            if (options.comparison > 0) {
                return 'om ' + result;
            }
            else {
                return result + ' siden';
            }
        }
        return result;
    }
    return {
        localize: localize
    };
}
var build_distance_in_words_locale$16 = buildDistanceInWordsLocale$16;
function buildFormatLocale$16() {
    var months3char = ['jan.', 'feb.', 'mars', 'april', 'mai', 'juni', 'juli', 'aug.', 'sep.', 'okt.', 'nov.', 'des.'];
    var monthsFull = ['januar', 'februar', 'mars', 'april', 'mai', 'juni', 'juli', 'august', 'september', 'oktober', 'november', 'desember'];
    var weekdays2char = ['sø', 'ma', 'ti', 'on', 'to', 'fr', 'lø'];
    var weekdays3char = ['sø.', 'ma.', 'ti.', 'on.', 'to.', 'fr.', 'lø.'];
    var weekdaysFull = ['søndag', 'mandag', 'tirsdag', 'onsdag', 'torsdag', 'fredag', 'lørdag'];
    var meridiemUppercase = ['AM', 'PM'];
    var meridiemLowercase = ['am', 'pm'];
    var meridiemFull = ['a.m.', 'p.m.'];
    var formatters = {
        // Month: Jan, Feb, ..., Dec
        'MMM': function (date) {
            return months3char[date.getMonth()];
        },
        // Month: January, February, ..., December
        'MMMM': function (date) {
            return monthsFull[date.getMonth()];
        },
        // Day of week: Su, Mo, ..., Sa
        'dd': function (date) {
            return weekdays2char[date.getDay()];
        },
        // Day of week: Sun, Mon, ..., Sat
        'ddd': function (date) {
            return weekdays3char[date.getDay()];
        },
        // Day of week: Sunday, Monday, ..., Saturday
        'dddd': function (date) {
            return weekdaysFull[date.getDay()];
        },
        // AM, PM
        'A': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemUppercase[1] : meridiemUppercase[0];
        },
        // am, pm
        'a': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemLowercase[1] : meridiemLowercase[0];
        },
        // a.m., p.m.
        'aa': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemFull[1] : meridiemFull[0];
        }
    };
    // Generate ordinal version of formatters: M -> Mo, D -> Do, etc.
    var ordinalFormatters = ['M', 'D', 'DDD', 'd', 'Q', 'W'];
    ordinalFormatters.forEach(function (formatterToken) {
        formatters[formatterToken + 'o'] = function (date, formatters) {
            return ordinal$6(formatters[formatterToken](date));
        };
    });
    return {
        formatters: formatters,
        formattingTokensRegExp: build_formatting_tokens_reg_exp(formatters)
    };
}
function ordinal$6(number) {
    return number + '.';
}
var build_format_locale$16 = buildFormatLocale$16;
/**
 * @category Locales
 * @summary Norwegian Bokmål locale.
 * @author Hans-Kristian Koren [@Hanse]{@link https://github.com/Hanse}
 */
var nb = {
    distanceInWords: build_distance_in_words_locale$16(),
    format: build_format_locale$16()
};
var nb$2 = Object.freeze({
    default: nb,
    __moduleExports: nb
});
function buildDistanceInWordsLocale$18() {
    var distanceInWordsLocale = {
        lessThanXSeconds: {
            one: "menys d'un segon",
            other: 'menys de {{count}} segons'
        },
        xSeconds: {
            one: '1 segon',
            other: '{{count}} segons'
        },
        halfAMinute: 'mig minut',
        lessThanXMinutes: {
            one: "menys d'un minut",
            other: 'menys de {{count}} minuts'
        },
        xMinutes: {
            one: '1 minut',
            other: '{{count}} minuts'
        },
        aboutXHours: {
            one: 'aproximadament una hora',
            other: 'aproximadament {{count}} hores'
        },
        xHours: {
            one: '1 hora',
            other: '{{count}} hores'
        },
        xDays: {
            one: '1 dia',
            other: '{{count}} dies'
        },
        aboutXMonths: {
            one: 'aproximadament un mes',
            other: 'aproximadament {{count}} mesos'
        },
        xMonths: {
            one: '1 mes',
            other: '{{count}} mesos'
        },
        aboutXYears: {
            one: 'aproximadament un any',
            other: 'aproximadament {{count}} anys'
        },
        xYears: {
            one: '1 any',
            other: '{{count}} anys'
        },
        overXYears: {
            one: "més d'un any",
            other: 'més de {{count}} anys'
        },
        almostXYears: {
            one: 'gairebé un any',
            other: 'gairebé {{count}} anys'
        }
    };
    function localize(token, count, options) {
        options = options || {};
        var result;
        if (typeof distanceInWordsLocale[token] === 'string') {
            result = distanceInWordsLocale[token];
        }
        else if (count === 1) {
            result = distanceInWordsLocale[token].one;
        }
        else {
            result = distanceInWordsLocale[token].other.replace('{{count}}', count);
        }
        if (options.addSuffix) {
            if (options.comparison > 0) {
                return 'en ' + result;
            }
            else {
                return 'fa ' + result;
            }
        }
        return result;
    }
    return {
        localize: localize
    };
}
var build_distance_in_words_locale$18 = buildDistanceInWordsLocale$18;
function buildFormatLocale$18() {
    var months3char = ['gen', 'feb', 'mar', 'abr', 'mai', 'jun', 'jul', 'ago', 'set', 'oct', 'nov', 'des'];
    var monthsFull = ['gener', 'febrer', 'març', 'abril', 'maig', 'juny', 'juliol', 'agost', 'setembre', 'octobre', 'novembre', 'desembre'];
    var weekdays2char = ['dg', 'dl', 'dt', 'dc', 'dj', 'dv', 'ds'];
    var weekdays3char = ['dge', 'dls', 'dts', 'dcs', 'djs', 'dvs', 'dss'];
    var weekdaysFull = ['diumenge', 'dilluns', 'dimarts', 'dimecres', 'dijous', 'divendres', 'dissabte'];
    var meridiemUppercase = ['AM', 'PM'];
    var meridiemLowercase = ['am', 'pm'];
    var meridiemFull = ['a.m.', 'p.m.'];
    var formatters = {
        // Month: Jan, Feb, ..., Dec
        'MMM': function (date) {
            return months3char[date.getMonth()];
        },
        // Month: January, February, ..., December
        'MMMM': function (date) {
            return monthsFull[date.getMonth()];
        },
        // Day of week: Su, Mo, ..., Sa
        'dd': function (date) {
            return weekdays2char[date.getDay()];
        },
        // Day of week: Sun, Mon, ..., Sat
        'ddd': function (date) {
            return weekdays3char[date.getDay()];
        },
        // Day of week: Sunday, Monday, ..., Saturday
        'dddd': function (date) {
            return weekdaysFull[date.getDay()];
        },
        // AM, PM
        'A': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemUppercase[1] : meridiemUppercase[0];
        },
        // am, pm
        'a': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemLowercase[1] : meridiemLowercase[0];
        },
        // a.m., p.m.
        'aa': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemFull[1] : meridiemFull[0];
        }
    };
    // Generate ordinal version of formatters: M -> Mo, D -> Do, etc.
    var ordinalFormatters = ['M', 'D', 'DDD', 'd', 'Q', 'W'];
    ordinalFormatters.forEach(function (formatterToken) {
        formatters[formatterToken + 'o'] = function (date, formatters) {
            return ordinal$7(formatters[formatterToken](date));
        };
    });
    return {
        formatters: formatters,
        formattingTokensRegExp: build_formatting_tokens_reg_exp(formatters)
    };
}
function ordinal$7(number) {
    switch (number) {
        case 1:
            return '1r';
        case 2:
            return '2n';
        case 3:
            return '3r';
        case 4:
            return '4t';
        default:
            return number + 'è';
    }
}
var build_format_locale$18 = buildFormatLocale$18;
/**
 * @category Locales
 * @summary Catalan locale.
 * @author Guillermo Grau [@guigrpa]{@link https://github.com/guigrpa}
 */
var ca = {
    distanceInWords: build_distance_in_words_locale$18(),
    format: build_format_locale$18()
};
var ca$2 = Object.freeze({
    default: ca,
    __moduleExports: ca
});
function buildDistanceInWordsLocale$20() {
    var distanceInWordsLocale = {
        lessThanXSeconds: {
            one: 'kurang dari 1 detik',
            other: 'kurang dari {{count}} detik'
        },
        xSeconds: {
            one: '1 detik',
            other: '{{count}} detik'
        },
        halfAMinute: 'setengah menit',
        lessThanXMinutes: {
            one: 'kurang dari 1 menit',
            other: 'kurang dari {{count}} menit'
        },
        xMinutes: {
            one: '1 menit',
            other: '{{count}} menit'
        },
        aboutXHours: {
            one: 'sekitar 1 jam',
            other: 'sekitar {{count}} jam'
        },
        xHours: {
            one: '1 jam',
            other: '{{count}} jam'
        },
        xDays: {
            one: '1 hari',
            other: '{{count}} hari'
        },
        aboutXMonths: {
            one: 'sekitar 1 bulan',
            other: 'sekitar {{count}} bulan'
        },
        xMonths: {
            one: '1 bulan',
            other: '{{count}} bulan'
        },
        aboutXYears: {
            one: 'sekitar 1 tahun',
            other: 'sekitar {{count}} tahun'
        },
        xYears: {
            one: '1 tahun',
            other: '{{count}} tahun'
        },
        overXYears: {
            one: 'lebih dari 1 tahun',
            other: 'lebih dari {{count}} tahun'
        },
        almostXYears: {
            one: 'hampir 1 tahun',
            other: 'hampir {{count}} tahun'
        }
    };
    function localize(token, count, options) {
        options = options || {};
        var result;
        if (typeof distanceInWordsLocale[token] === 'string') {
            result = distanceInWordsLocale[token];
        }
        else if (count === 1) {
            result = distanceInWordsLocale[token].one;
        }
        else {
            result = distanceInWordsLocale[token].other.replace('{{count}}', count);
        }
        if (options.addSuffix) {
            if (options.comparison > 0) {
                return 'dalam waktu ' + result;
            }
            else {
                return result + ' yang lalu';
            }
        }
        return result;
    }
    return {
        localize: localize
    };
}
var build_distance_in_words_locale$20 = buildDistanceInWordsLocale$20;
function buildFormatLocale$20() {
    // Note: in Indonesian, the names of days of the week and months are capitalized.
    // If you are making a new locale based on this one, check if the same is true for the language you're working on.
    // Generally, formatted dates should look like they are in the middle of a sentence,
    // e.g. in Spanish language the weekdays and months should be in the lowercase.
    var months3char = ['Jan', 'Feb', 'Mar', 'Apr', 'Mei', 'Jun', 'Jul', 'Agu', 'Sep', 'Okt', 'Nov', 'Des'];
    var monthsFull = ['Januari', 'Februari', 'Maret', 'April', 'Mei', 'Juni', 'Juli', 'Agustus', 'September', 'Oktober', 'November', 'Desember'];
    var weekdays2char = ['Mi', 'Sn', 'Sl', 'Ra', 'Ka', 'Ju', 'Sa'];
    var weekdays3char = ['Min', 'Sen', 'Sel', 'Rab', 'Kam', 'Jum', 'Sab'];
    var weekdaysFull = ['Minggu', 'Senin', 'Selasa', 'Rabu', 'Kamis', 'Jumat', 'Sabtu'];
    var meridiemUppercase = ['AM', 'PM'];
    var meridiemLowercase = ['am', 'pm'];
    var meridiemFull = ['a.m.', 'p.m.'];
    var formatters = {
        // Month: Jan, Feb, ..., Dec
        'MMM': function (date) {
            return months3char[date.getMonth()];
        },
        // Month: January, February, ..., December
        'MMMM': function (date) {
            return monthsFull[date.getMonth()];
        },
        // Day of week: Su, Mo, ..., Sa
        'dd': function (date) {
            return weekdays2char[date.getDay()];
        },
        // Day of week: Sun, Mon, ..., Sat
        'ddd': function (date) {
            return weekdays3char[date.getDay()];
        },
        // Day of week: Sunday, Monday, ..., Saturday
        'dddd': function (date) {
            return weekdaysFull[date.getDay()];
        },
        // AM, PM
        'A': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemUppercase[1] : meridiemUppercase[0];
        },
        // am, pm
        'a': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemLowercase[1] : meridiemLowercase[0];
        },
        // a.m., p.m.
        'aa': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemFull[1] : meridiemFull[0];
        }
    };
    // Generate ordinal version of formatters: M -> Mo, D -> Do, etc.
    var ordinalFormatters = ['M', 'D', 'DDD', 'd', 'Q', 'W'];
    ordinalFormatters.forEach(function (formatterToken) {
        formatters[formatterToken + 'o'] = function (date, formatters) {
            return ordinal$8(formatters[formatterToken](date));
        };
    });
    return {
        formatters: formatters,
        formattingTokensRegExp: build_formatting_tokens_reg_exp(formatters)
    };
}
function ordinal$8(number) {
    switch (number) {
        case 1:
            return 'pertama';
        case 2:
            return 'kedua';
        case 3:
            return 'ketiga';
        default:
            return 'ke-' + number;
    }
}
var build_format_locale$20 = buildFormatLocale$20;
/**
 * @category Locales
 * @summary Indonesian locale.
 * @author Rahmat Budiharso [@rbudiharso]{@link https://github.com/rbudiharso}
 * @author Benget Nata [@bentinata]{@link https://github.com/bentinata}
 */
var id = {
    distanceInWords: build_distance_in_words_locale$20(),
    format: build_format_locale$20()
};
var id$2 = Object.freeze({
    default: id,
    __moduleExports: id
});
function buildDistanceInWordsLocale$22() {
    var distanceInWordsLocale = {
        lessThanXSeconds: {
            one: 'meno di un secondo',
            other: 'meno di {{count}} secondi'
        },
        xSeconds: {
            one: 'un secondo',
            other: '{{count}} secondi'
        },
        halfAMinute: 'alcuni secondi',
        lessThanXMinutes: {
            one: 'meno di un minuto',
            other: 'meno di {{count}} minuti'
        },
        xMinutes: {
            one: 'un minuto',
            other: '{{count}} minuti'
        },
        aboutXHours: {
            one: 'circa un\'ora',
            other: 'circa {{count}} ore'
        },
        xHours: {
            one: 'un\'ora',
            other: '{{count}} ore'
        },
        xDays: {
            one: 'un giorno',
            other: '{{count}} giorni'
        },
        aboutXMonths: {
            one: 'circa un mese',
            other: 'circa {{count}} mesi'
        },
        xMonths: {
            one: 'un mese',
            other: '{{count}} mesi'
        },
        aboutXYears: {
            one: 'circa un anno',
            other: 'circa {{count}} anni'
        },
        xYears: {
            one: 'un anno',
            other: '{{count}} anni'
        },
        overXYears: {
            one: 'più di un anno',
            other: 'più di {{count}} anni'
        },
        almostXYears: {
            one: 'quasi un anno',
            other: 'quasi {{count}} anni'
        }
    };
    function localize(token, count, options) {
        options = options || {};
        var result;
        if (typeof distanceInWordsLocale[token] === 'string') {
            result = distanceInWordsLocale[token];
        }
        else if (count === 1) {
            result = distanceInWordsLocale[token].one;
        }
        else {
            result = distanceInWordsLocale[token].other.replace('{{count}}', count);
        }
        if (options.addSuffix) {
            if (options.comparison > 0) {
                return 'tra ' + result;
            }
            else {
                return result + ' fa';
            }
        }
        return result;
    }
    return {
        localize: localize
    };
}
var build_distance_in_words_locale$22 = buildDistanceInWordsLocale$22;
function buildFormatLocale$22() {
    var months3char = ['gen', 'feb', 'mar', 'apr', 'mag', 'giu', 'lug', 'ago', 'set', 'ott', 'nov', 'dic'];
    var monthsFull = ['gennaio', 'febbraio', 'marzo', 'aprile', 'maggio', 'giugno', 'luglio', 'agosto', 'settembre', 'ottobre', 'novembre', 'dicembre'];
    var weekdays2char = ['do', 'lu', 'ma', 'me', 'gi', 've', 'sa'];
    var weekdays3char = ['dom', 'lun', 'mar', 'mer', 'gio', 'ven', 'sab'];
    var weekdaysFull = ['domenica', 'lunedì', 'martedì', 'mercoledì', 'giovedì', 'venerdì', 'sabato'];
    var meridiemUppercase = ['AM', 'PM'];
    var meridiemLowercase = ['am', 'pm'];
    var meridiemFull = ['a.m.', 'p.m.'];
    var formatters = {
        // Month: Jan, Feb, ..., Dec
        'MMM': function (date) {
            return months3char[date.getMonth()];
        },
        // Month: January, February, ..., December
        'MMMM': function (date) {
            return monthsFull[date.getMonth()];
        },
        // Day of week: Su, Mo, ..., Sa
        'dd': function (date) {
            return weekdays2char[date.getDay()];
        },
        // Day of week: Sun, Mon, ..., Sat
        'ddd': function (date) {
            return weekdays3char[date.getDay()];
        },
        // Day of week: Sunday, Monday, ..., Saturday
        'dddd': function (date) {
            return weekdaysFull[date.getDay()];
        },
        // AM, PM
        'A': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemUppercase[1] : meridiemUppercase[0];
        },
        // am, pm
        'a': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemLowercase[1] : meridiemLowercase[0];
        },
        // a.m., p.m.
        'aa': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemFull[1] : meridiemFull[0];
        }
    };
    // Generate ordinal version of formatters: M -> Mo, D -> Do, etc.
    var ordinalFormatters = ['M', 'D', 'DDD', 'd', 'Q', 'W'];
    ordinalFormatters.forEach(function (formatterToken) {
        formatters[formatterToken + 'o'] = function (date, formatters) {
            return ordinal$9(formatters[formatterToken](date));
        };
    });
    return {
        formatters: formatters,
        formattingTokensRegExp: build_formatting_tokens_reg_exp(formatters)
    };
}
function ordinal$9(number) {
    return number + 'º';
}
var build_format_locale$22 = buildFormatLocale$22;
/**
 * @category Locales
 * @summary Italian locale.
 * @author Alberto Restifo [@albertorestifo]{@link https://github.com/albertorestifo}
 */
var it = {
    distanceInWords: build_distance_in_words_locale$22(),
    format: build_format_locale$22()
};
var it$2 = Object.freeze({
    default: it,
    __moduleExports: it
});
function declensionGroup(scheme, count) {
    if (count === 1) {
        return scheme.one;
    }
    var rem100 = count % 100;
    // ends with 11-20
    if (rem100 <= 20 && rem100 > 10) {
        return scheme.other;
    }
    var rem10 = rem100 % 10;
    // ends with 2, 3, 4
    if (rem10 >= 2 && rem10 <= 4) {
        return scheme.twoFour;
    }
    return scheme.other;
}
function declension$1(scheme, count, time) {
    time = time || 'regular';
    var group = declensionGroup(scheme, count);
    var finalText = group[time] || group;
    return finalText.replace('{{count}}', count);
}
function buildDistanceInWordsLocale$24() {
    var distanceInWordsLocale = {
        lessThanXSeconds: {
            one: {
                regular: 'mniej niż sekunda',
                past: 'mniej niż sekundę',
                future: 'mniej niż sekundę'
            },
            twoFour: 'mniej niż {{count}} sekundy',
            other: 'mniej niż {{count}} sekund'
        },
        xSeconds: {
            one: {
                regular: 'sekunda',
                past: 'sekundę',
                future: 'sekundę'
            },
            twoFour: '{{count}} sekundy',
            other: '{{count}} sekund'
        },
        halfAMinute: {
            one: 'pół minuty',
            twoFour: 'pół minuty',
            other: 'pół minuty'
        },
        lessThanXMinutes: {
            one: {
                regular: 'mniej niż minuta',
                past: 'mniej niż minutę',
                future: 'mniej niż minutę'
            },
            twoFour: 'mniej niż {{count}} minuty',
            other: 'mniej niż {{count}} minut'
        },
        xMinutes: {
            one: {
                regular: 'minuta',
                past: 'minutę',
                future: 'minutę'
            },
            twoFour: '{{count}} minuty',
            other: '{{count}} minut'
        },
        aboutXHours: {
            one: {
                regular: 'około godzina',
                past: 'około godziny',
                future: 'około godzinę'
            },
            twoFour: 'około {{count}} godziny',
            other: 'około {{count}} godzin'
        },
        xHours: {
            one: {
                regular: 'godzina',
                past: 'godzinę',
                future: 'godzinę'
            },
            twoFour: '{{count}} godziny',
            other: '{{count}} godzin'
        },
        xDays: {
            one: {
                regular: 'dzień',
                past: 'dzień',
                future: '1 dzień'
            },
            twoFour: '{{count}} dni',
            other: '{{count}} dni'
        },
        aboutXMonths: {
            one: 'około miesiąc',
            twoFour: 'około {{count}} miesiące',
            other: 'około {{count}} miesięcy'
        },
        xMonths: {
            one: 'miesiąc',
            twoFour: '{{count}} miesiące',
            other: '{{count}} miesięcy'
        },
        aboutXYears: {
            one: 'około rok',
            twoFour: 'około {{count}} lata',
            other: 'około {{count}} lat'
        },
        xYears: {
            one: 'rok',
            twoFour: '{{count}} lata',
            other: '{{count}} lat'
        },
        overXYears: {
            one: 'ponad rok',
            twoFour: 'ponad {{count}} lata',
            other: 'ponad {{count}} lat'
        },
        almostXYears: {
            one: 'prawie rok',
            twoFour: 'prawie {{count}} lata',
            other: 'prawie {{count}} lat'
        }
    };
    function localize(token, count, options) {
        options = options || {};
        var scheme = distanceInWordsLocale[token];
        if (!options.addSuffix) {
            return declension$1(scheme, count);
        }
        if (options.comparison > 0) {
            return 'za ' + declension$1(scheme, count, 'future');
        }
        else {
            return declension$1(scheme, count, 'past') + ' temu';
        }
    }
    return {
        localize: localize
    };
}
var build_distance_in_words_locale$24 = buildDistanceInWordsLocale$24;
function buildFormatLocale$24() {
    var months3char = ['sty', 'lut', 'mar', 'kwi', 'maj', 'cze', 'lip', 'sie', 'wrz', 'paź', 'lis', 'gru'];
    var monthsFull = ['styczeń', 'luty', 'marzec', 'kwiecień', 'maj', 'czerwiec', 'lipiec', 'sierpień', 'wrzesień', 'październik', 'listopad', 'grudzień'];
    var weekdays2char = ['nd', 'pn', 'wt', 'śr', 'cz', 'pt', 'sb'];
    var weekdays3char = ['niedz.', 'pon.', 'wt.', 'śr.', 'czw.', 'piąt.', 'sob.'];
    var weekdaysFull = ['niedziela', 'poniedziałek', 'wtorek', 'środa', 'czwartek', 'piątek', 'sobota'];
    var meridiem = ['w nocy', 'rano', 'po południu', 'wieczorem'];
    var formatters = {
        // Month: Jan, Feb, ..., Dec
        'MMM': function (date) {
            return months3char[date.getMonth()];
        },
        // Month: January, February, ..., December
        'MMMM': function (date) {
            return monthsFull[date.getMonth()];
        },
        // Day of week: Su, Mo, ..., Sa
        'dd': function (date) {
            return weekdays2char[date.getDay()];
        },
        // Day of week: Sun, Mon, ..., Sat
        'ddd': function (date) {
            return weekdays3char[date.getDay()];
        },
        // Day of week: Sunday, Monday, ..., Saturday
        'dddd': function (date) {
            return weekdaysFull[date.getDay()];
        },
        // Time of day
        'A': function (date) {
            var hours = date.getHours();
            if (hours >= 17) {
                return meridiem[3];
            }
            else if (hours >= 12) {
                return meridiem[2];
            }
            else if (hours >= 4) {
                return meridiem[1];
            }
            else {
                return meridiem[0];
            }
        }
    };
    formatters.a = formatters.A;
    formatters.aa = formatters.A;
    // Generate ordinal version of formatters: M -> Mo, D -> Do, etc.
    var ordinalFormatters = ['M', 'D', 'DDD', 'd', 'Q', 'W'];
    ordinalFormatters.forEach(function (formatterToken) {
        formatters[formatterToken + 'o'] = function (date, formatters) {
            // Well, it should be just a number without any suffix
            return formatters[formatterToken](date).toString();
        };
    });
    return {
        formatters: formatters,
        formattingTokensRegExp: build_formatting_tokens_reg_exp(formatters)
    };
}
var build_format_locale$24 = buildFormatLocale$24;
/**
 * @category Locales
 * @summary Polish locale.
 * @author Mateusz Derks [@ertrzyiks]{@link https://github.com/ertrzyiks}
 * @author Just RAG [@justrag]{@link https://github.com/justrag}
 */
var pl = {
    distanceInWords: build_distance_in_words_locale$24(),
    format: build_format_locale$24()
};
var pl$2 = Object.freeze({
    default: pl,
    __moduleExports: pl
});
function buildDistanceInWordsLocale$26() {
    var distanceInWordsLocale = {
        lessThanXSeconds: {
            one: 'menos de um segundo',
            other: 'menos de {{count}} segundos'
        },
        xSeconds: {
            one: '1 segundo',
            other: '{{count}} segundos'
        },
        halfAMinute: 'meio minuto',
        lessThanXMinutes: {
            one: 'menos de um minuto',
            other: 'menos de {{count}} minutos'
        },
        xMinutes: {
            one: '1 minuto',
            other: '{{count}} minutos'
        },
        aboutXHours: {
            one: 'aproximadamente 1 hora',
            other: 'aproximadamente {{count}} horas'
        },
        xHours: {
            one: '1 hora',
            other: '{{count}} horas'
        },
        xDays: {
            one: '1 dia',
            other: '{{count}} dias'
        },
        aboutXMonths: {
            one: 'aproximadamente 1 mês',
            other: 'aproximadamente {{count}} meses'
        },
        xMonths: {
            one: '1 mês',
            other: '{{count}} meses'
        },
        aboutXYears: {
            one: 'aproximadamente 1 ano',
            other: 'aproximadamente {{count}} anos'
        },
        xYears: {
            one: '1 ano',
            other: '{{count}} anos'
        },
        overXYears: {
            one: 'mais de 1 ano',
            other: 'mais de {{count}} anos'
        },
        almostXYears: {
            one: 'quase 1 ano',
            other: 'quase {{count}} anos'
        }
    };
    function localize(token, count, options) {
        options = options || {};
        var result;
        if (typeof distanceInWordsLocale[token] === 'string') {
            result = distanceInWordsLocale[token];
        }
        else if (count === 1) {
            result = distanceInWordsLocale[token].one;
        }
        else {
            result = distanceInWordsLocale[token].other.replace('{{count}}', count);
        }
        if (options.addSuffix) {
            if (options.comparison > 0) {
                return 'daqui a ' + result;
            }
            else {
                return 'há ' + result;
            }
        }
        return result;
    }
    return {
        localize: localize
    };
}
var build_distance_in_words_locale$26 = buildDistanceInWordsLocale$26;
function buildFormatLocale$26() {
    var months3char = ['jan', 'fev', 'mar', 'abr', 'mai', 'jun', 'jul', 'ago', 'set', 'out', 'nov', 'dez'];
    var monthsFull = ['janeiro', 'fevereiro', 'março', 'abril', 'maio', 'junho', 'julho', 'agosto', 'setembro', 'outubro', 'novembro', 'dezembro'];
    var weekdays2char = ['do', 'se', 'te', 'qa', 'qi', 'se', 'sa'];
    var weekdays3char = ['dom', 'seg', 'ter', 'qua', 'qui', 'sex', 'sáb'];
    var weekdaysFull = ['domingo', 'segunda-feira', 'terça-feira', 'quarta-feira', 'quinta-feira', 'sexta-feira', 'sábado'];
    var meridiemUppercase = ['AM', 'PM'];
    var meridiemLowercase = ['am', 'pm'];
    var meridiemFull = ['a.m.', 'p.m.'];
    var formatters = {
        // Month: Jan, Feb, ..., Dec
        'MMM': function (date) {
            return months3char[date.getMonth()];
        },
        // Month: January, February, ..., December
        'MMMM': function (date) {
            return monthsFull[date.getMonth()];
        },
        // Day of week: Su, Mo, ..., Sa
        'dd': function (date) {
            return weekdays2char[date.getDay()];
        },
        // Day of week: Sun, Mon, ..., Sat
        'ddd': function (date) {
            return weekdays3char[date.getDay()];
        },
        // Day of week: Sunday, Monday, ..., Saturday
        'dddd': function (date) {
            return weekdaysFull[date.getDay()];
        },
        // AM, PM
        'A': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemUppercase[1] : meridiemUppercase[0];
        },
        // am, pm
        'a': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemLowercase[1] : meridiemLowercase[0];
        },
        // a.m., p.m.
        'aa': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemFull[1] : meridiemFull[0];
        }
    };
    // Generate ordinal version of formatters: M -> Mo, D -> Do, etc.
    var ordinalFormatters = ['M', 'D', 'DDD', 'd', 'Q', 'W'];
    ordinalFormatters.forEach(function (formatterToken) {
        formatters[formatterToken + 'o'] = function (date, formatters) {
            return ordinal$10(formatters[formatterToken](date));
        };
    });
    return {
        formatters: formatters,
        formattingTokensRegExp: build_formatting_tokens_reg_exp(formatters)
    };
}
function ordinal$10(number) {
    return number + 'º';
}
var build_format_locale$26 = buildFormatLocale$26;
/**
 * @category Locales
 * @summary Portuguese locale.
 * @author Dário Freire [@dfreire]{@link https://github.com/dfreire}
 */
var pt = {
    distanceInWords: build_distance_in_words_locale$26(),
    format: build_format_locale$26()
};
var pt$2 = Object.freeze({
    default: pt,
    __moduleExports: pt
});
function buildDistanceInWordsLocale$28() {
    var distanceInWordsLocale = {
        lessThanXSeconds: {
            singular: 'mindre än en sekund',
            plural: 'mindre än {{count}} sekunder'
        },
        xSeconds: {
            singular: 'en sekund',
            plural: '{{count}} sekunder'
        },
        halfAMinute: 'en halv minut',
        lessThanXMinutes: {
            singular: 'mindre än en minut',
            plural: 'mindre än {{count}} minuter'
        },
        xMinutes: {
            singular: 'en minut',
            plural: '{{count}} minuter'
        },
        aboutXHours: {
            singular: 'ungefär en timme',
            plural: 'ungefär {{count}} timmar'
        },
        xHours: {
            singular: 'en timme',
            plural: '{{count}} timmar'
        },
        xDays: {
            singular: 'en dag',
            plural: '{{count}} dagar'
        },
        aboutXMonths: {
            singular: 'ungefär en månad',
            plural: 'ungefär {{count}} månader'
        },
        xMonths: {
            singular: 'en månad',
            plural: '{{count}} månader'
        },
        aboutXYears: {
            singular: 'ungefär ett år',
            plural: 'ungefär {{count}} år'
        },
        xYears: {
            singular: 'ett år',
            plural: '{{count}} år'
        },
        overXYears: {
            singular: 'över ett år',
            plural: 'över {{count}} år'
        },
        almostXYears: {
            singular: 'nästan ett år',
            plural: 'nästan {{count}} år'
        }
    };
    var wordMapping = [
        'noll',
        'en',
        'två',
        'tre',
        'fyra',
        'fem',
        'sex',
        'sju',
        'åtta',
        'nio',
        'tio',
        'elva',
        'tolv'
    ];
    function localize(token, count, options) {
        options = options || {};
        var translation = distanceInWordsLocale[token];
        var result;
        if (typeof translation === 'string') {
            result = translation;
        }
        else if (count === 0 || count > 1) {
            result = translation.plural.replace('{{count}}', count < 13 ? wordMapping[count] : count);
        }
        else {
            result = translation.singular;
        }
        if (options.addSuffix) {
            if (options.comparison > 0) {
                return 'om ' + result;
            }
            else {
                return result + ' sedan';
            }
        }
        return result;
    }
    return {
        localize: localize
    };
}
var build_distance_in_words_locale$28 = buildDistanceInWordsLocale$28;
function buildFormatLocale$28() {
    var months3char = ['jan', 'feb', 'mar', 'apr', 'maj', 'jun', 'jul', 'aug', 'sep', 'okt', 'nov', 'dec'];
    var monthsFull = ['januari', 'februari', 'mars', 'april', 'maj', 'juni', 'juli', 'augusti', 'september', 'oktober', 'november', 'december'];
    var weekdays2char = ['sö', 'må', 'ti', 'on', 'to', 'fr', 'lö'];
    var weekdays3char = ['sön', 'mån', 'tis', 'ons', 'tor', 'fre', 'lör'];
    var weekdaysFull = ['söndag', 'måndag', 'tisdag', 'onsdag', 'torsdag', 'fredag', 'lördag'];
    var meridiemFull = ['f.m.', 'e.m.'];
    var formatters = {
        // Month: Jan, Feb, ..., Dec
        'MMM': function (date) {
            return months3char[date.getMonth()];
        },
        // Month: January, February, ..., December
        'MMMM': function (date) {
            return monthsFull[date.getMonth()];
        },
        // Day of week: Su, Mo, ..., Sa
        'dd': function (date) {
            return weekdays2char[date.getDay()];
        },
        // Day of week: Sun, Mon, ..., Sat
        'ddd': function (date) {
            return weekdays3char[date.getDay()];
        },
        // Day of week: Sunday, Monday, ..., Saturday
        'dddd': function (date) {
            return weekdaysFull[date.getDay()];
        },
        // a.m., p.m.
        'aa': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemFull[1] : meridiemFull[0];
        }
    };
    formatters.A = formatters.aa;
    formatters.a = formatters.aa;
    // Generate ordinal version of formatters: M -> Mo, D -> Do, etc.
    var ordinalFormatters = ['M', 'D', 'DDD', 'd', 'Q', 'W'];
    ordinalFormatters.forEach(function (formatterToken) {
        formatters[formatterToken + 'o'] = function (date, formatters) {
            return ordinal$11(formatters[formatterToken](date));
        };
    });
    return {
        formatters: formatters,
        formattingTokensRegExp: build_formatting_tokens_reg_exp(formatters)
    };
}
function ordinal$11(number) {
    var rem100 = number % 100;
    if (rem100 > 20 || rem100 < 10) {
        switch (rem100 % 10) {
            case 1:
            case 2:
                return number + ':a';
        }
    }
    return number + ':e';
}
var build_format_locale$28 = buildFormatLocale$28;
/**
 * @category Locales
 * @summary Swedish locale.
 * @author Johannes Ulén [@ejulen]{@link https://github.com/ejulen}
 */
var sv = {
    distanceInWords: build_distance_in_words_locale$28(),
    format: build_format_locale$28()
};
var sv$2 = Object.freeze({
    default: sv,
    __moduleExports: sv
});
function buildDistanceInWordsLocale$30() {
    var distanceInWordsLocale = {
        lessThanXSeconds: {
            one: 'moins d’une seconde',
            other: 'moins de {{count}} secondes'
        },
        xSeconds: {
            one: '1 seconde',
            other: '{{count}} secondes'
        },
        halfAMinute: '30 secondes',
        lessThanXMinutes: {
            one: 'moins d’une minute',
            other: 'moins de {{count}} minutes'
        },
        xMinutes: {
            one: '1 minute',
            other: '{{count}} minutes'
        },
        aboutXHours: {
            one: 'environ 1 heure',
            other: 'environ {{count}} heures'
        },
        xHours: {
            one: '1 heure',
            other: '{{count}} heures'
        },
        xDays: {
            one: '1 jour',
            other: '{{count}} jours'
        },
        aboutXMonths: {
            one: 'environ 1 mois',
            other: 'environ {{count}} mois'
        },
        xMonths: {
            one: '1 mois',
            other: '{{count}} mois'
        },
        aboutXYears: {
            one: 'environ 1 an',
            other: 'environ {{count}} ans'
        },
        xYears: {
            one: '1 an',
            other: '{{count}} ans'
        },
        overXYears: {
            one: 'plus d’un an',
            other: 'plus de {{count}} ans'
        },
        almostXYears: {
            one: 'presqu’un an',
            other: 'presque {{count}} ans'
        }
    };
    function localize(token, count, options) {
        options = options || {};
        var result;
        if (typeof distanceInWordsLocale[token] === 'string') {
            result = distanceInWordsLocale[token];
        }
        else if (count === 1) {
            result = distanceInWordsLocale[token].one;
        }
        else {
            result = distanceInWordsLocale[token].other.replace('{{count}}', count);
        }
        if (options.addSuffix) {
            if (options.comparison > 0) {
                return 'dans ' + result;
            }
            else {
                return 'il y a ' + result;
            }
        }
        return result;
    }
    return {
        localize: localize
    };
}
var build_distance_in_words_locale$30 = buildDistanceInWordsLocale$30;
function buildFormatLocale$30() {
    var months3char = ['janv.', 'févr.', 'mars', 'avr.', 'mai', 'juin', 'juill.', 'août', 'sept.', 'oct.', 'nov.', 'déc.'];
    var monthsFull = ['janvier', 'février', 'mars', 'avril', 'mai', 'juin', 'juillet', 'août', 'septembre', 'octobre', 'novembre', 'décembre'];
    var weekdays2char = ['di', 'lu', 'ma', 'me', 'je', 've', 'sa'];
    var weekdays3char = ['dim.', 'lun.', 'mar.', 'mer.', 'jeu.', 'ven.', 'sam.'];
    var weekdaysFull = ['dimanche', 'lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi', 'samedi'];
    var meridiemUppercase = ['AM', 'PM'];
    var meridiemLowercase = ['am', 'pm'];
    var meridiemFull = ['du matin', 'de l’après-midi', 'du soir'];
    var formatters = {
        // Month: Jan, Feb, …, Dec
        'MMM': function (date) {
            return months3char[date.getMonth()];
        },
        // Month: January, February, …, December
        'MMMM': function (date) {
            return monthsFull[date.getMonth()];
        },
        // Day of week: Su, Mo, …, Sa
        'dd': function (date) {
            return weekdays2char[date.getDay()];
        },
        // Day of week: Sun, Mon, …, Sat
        'ddd': function (date) {
            return weekdays3char[date.getDay()];
        },
        // Day of week: Sunday, Monday, …, Saturday
        'dddd': function (date) {
            return weekdaysFull[date.getDay()];
        },
        // AM, PM
        'A': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemUppercase[1] : meridiemUppercase[0];
        },
        // am, pm
        'a': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemLowercase[1] : meridiemLowercase[0];
        },
        // a.m., p.m.
        'aa': function (date) {
            var hours = date.getHours();
            if (hours <= 12) {
                return meridiemFull[0];
            }
            if (hours <= 16) {
                return meridiemFull[1];
            }
            return meridiemFull[2];
        },
        // ISO week, ordinal version: 1st, 2nd, …, 53rd
        // NOTE: Week has feminine grammatical gender in French: semaine
        'Wo': function (date, formatters) {
            return feminineOrdinal(formatters.W(date));
        }
    };
    // Generate ordinal version of formatters: M → Mo, D → Do, etc.
    // NOTE: For words with masculine grammatical gender in French: mois, jour, trimestre
    var formatterTokens = ['M', 'D', 'DDD', 'd', 'Q'];
    formatterTokens.forEach(function (formatterToken) {
        formatters[formatterToken + 'o'] = function (date, formatters) {
            return masculineOrdinal(formatters[formatterToken](date));
        };
    });
    // Special case for day of month ordinals in long date format context:
    // 1er mars, 2 mars, 3 mars, …
    // See https://github.com/date-fns/date-fns/issues/437
    //
    // NOTE: The below implementation works because parsing of tokens inside a
    // format string is done by a greedy regular expression, i.e. longer tokens
    // have priority. E.g. formatter for "Do MMMM" has priority over individual
    // formatters for "Do" and "MMMM".
    var monthsTokens = ['MMM', 'MMMM'];
    monthsTokens.forEach(function (monthToken) {
        formatters['Do ' + monthToken] = function (date, commonFormatters) {
            var dayOfMonthToken = date.getDate() === 1
                ? 'Do'
                : 'D';
            var dayOfMonthFormatter = formatters[dayOfMonthToken] || commonFormatters[dayOfMonthToken];
            return dayOfMonthFormatter(date, commonFormatters) + ' ' + formatters[monthToken](date);
        };
    });
    return {
        formatters: formatters,
        formattingTokensRegExp: build_formatting_tokens_reg_exp(formatters)
    };
}
function masculineOrdinal(number) {
    if (number === 1) {
        return '1er';
    }
    return number + 'e';
}
function feminineOrdinal(number) {
    if (number === 1) {
        return '1re';
    }
    return number + 'e';
}
var build_format_locale$30 = buildFormatLocale$30;
/**
 * @category Locales
 * @summary French locale.
 * @author Jean Dupouy [@izeau]{@link https://github.com/izeau}
 * @author François B [@fbonzon]{@link https://github.com/fbonzon}
 */
var fr = {
    distanceInWords: build_distance_in_words_locale$30(),
    format: build_format_locale$30()
};
var fr$2 = Object.freeze({
    default: fr,
    __moduleExports: fr
});
function buildDistanceInWordsLocale$32() {
    var distanceInWordsLocale = {
        lessThanXSeconds: {
            one: 'bir saniyeden az',
            other: '{{count}} saniyeden az'
        },
        xSeconds: {
            one: '1 saniye',
            other: '{{count}} saniye'
        },
        halfAMinute: 'yarım dakika',
        lessThanXMinutes: {
            one: 'bir dakikadan az',
            other: '{{count}} dakikadan az'
        },
        xMinutes: {
            one: '1 dakika',
            other: '{{count}} dakika'
        },
        aboutXHours: {
            one: 'yaklaşık 1 saat',
            other: 'yaklaşık {{count}} saat'
        },
        xHours: {
            one: '1 saat',
            other: '{{count}} saat'
        },
        xDays: {
            one: '1 gün',
            other: '{{count}} gün'
        },
        aboutXMonths: {
            one: 'yaklaşık 1 ay',
            other: 'yaklaşık {{count}} ay'
        },
        xMonths: {
            one: '1 ay',
            other: '{{count}} ay'
        },
        aboutXYears: {
            one: 'yaklaşık 1 yıl',
            other: 'yaklaşık {{count}} yıl'
        },
        xYears: {
            one: '1 yıl',
            other: '{{count}} yıl'
        },
        overXYears: {
            one: '1 yıldan fazla',
            other: '{{count}} yıldan fazla'
        },
        almostXYears: {
            one: 'neredeyse 1 yıl',
            other: 'neredeyse {{count}} yıl'
        }
    };
    var extraWordTokens = [
        'lessThanXSeconds',
        'lessThanXMinutes',
        'overXYears'
    ];
    function localize(token, count, options) {
        options = options || {};
        var result;
        if (typeof distanceInWordsLocale[token] === 'string') {
            result = distanceInWordsLocale[token];
        }
        else if (count === 1) {
            result = distanceInWordsLocale[token].one;
        }
        else {
            result = distanceInWordsLocale[token].other.replace('{{count}}', count);
        }
        if (options.addSuffix) {
            var extraWord = '';
            if (extraWordTokens.indexOf(token) > -1) {
                extraWord = ' bir süre';
            }
            if (options.comparison > 0) {
                return result + extraWord + ' içinde';
            }
            else {
                return result + extraWord + ' önce';
            }
        }
        return result;
    }
    return {
        localize: localize
    };
}
var build_distance_in_words_locale$32 = buildDistanceInWordsLocale$32;
function buildFormatLocale$32() {
    // Note: in Turkish, the names of days of the week and months are capitalized.
    // If you are making a new locale based on this one, check if the same is true for the language you're working on.
    // Generally, formatted dates should look like they are in the middle of a sentence,
    // e.g. in Spanish language the weekdays and months should be in the lowercase.
    var months3char = ['Oca', 'Şub', 'Mar', 'Nis', 'May', 'Haz', 'Tem', 'Ağu', 'Eyl', 'Eki', 'Kas', 'Ara'];
    var monthsFull = ['Ocak', 'Şubat', 'Mart', 'Nisan', 'Mayıs', 'Haziran', 'Temmuz', 'Ağustos', 'Eylül', 'Ekim', 'Kasım', 'Aralık'];
    var weekdays2char = ['Pz', 'Pt', 'Sa', 'Ça', 'Pe', 'Cu', 'Ct'];
    var weekdays3char = ['Paz', 'Pts', 'Sal', 'Çar', 'Per', 'Cum', 'Cts'];
    var weekdaysFull = ['Pazar', 'Pazartesi', 'Salı', 'Çarşamba', 'Perşembe', 'Cuma', 'Cumartesi'];
    var meridiemUppercase = ['ÖÖ', 'ÖS'];
    var meridiemLowercase = ['öö', 'ös'];
    var meridiemFull = ['ö.ö.', 'ö.s.'];
    var formatters = {
        // Month: Jan, Feb, ..., Dec
        'MMM': function (date) {
            return months3char[date.getMonth()];
        },
        // Month: January, February, ..., December
        'MMMM': function (date) {
            return monthsFull[date.getMonth()];
        },
        // Day of week: Su, Mo, ..., Sa
        'dd': function (date) {
            return weekdays2char[date.getDay()];
        },
        // Day of week: Sun, Mon, ..., Sat
        'ddd': function (date) {
            return weekdays3char[date.getDay()];
        },
        // Day of week: Sunday, Monday, ..., Saturday
        'dddd': function (date) {
            return weekdaysFull[date.getDay()];
        },
        // AM, PM
        'A': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemUppercase[1] : meridiemUppercase[0];
        },
        // am, pm
        'a': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemLowercase[1] : meridiemLowercase[0];
        },
        // a.m., p.m.
        'aa': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemFull[1] : meridiemFull[0];
        }
    };
    // Generate ordinal version of formatters: M -> Mo, D -> Do, etc.
    var ordinalFormatters = ['M', 'D', 'DDD', 'd', 'Q', 'W'];
    ordinalFormatters.forEach(function (formatterToken) {
        formatters[formatterToken + 'o'] = function (date, formatters) {
            return ordinal$12(formatters[formatterToken](date));
        };
    });
    return {
        formatters: formatters,
        formattingTokensRegExp: build_formatting_tokens_reg_exp(formatters)
    };
}
function ordinal$12(number) {
    var suffixes = {
        1: '\'inci',
        2: '\'inci',
        3: '\'üncü',
        4: '\'üncü',
        5: '\'inci',
        6: '\'ıncı',
        7: '\'inci',
        8: '\'inci',
        9: '\'uncu',
        10: '\'uncu',
        20: '\'inci',
        30: '\'uncu',
        50: '\'inci',
        60: '\'ıncı',
        70: '\'inci',
        80: '\'inci',
        90: '\'ıncı',
        100: '\'üncü'
    };
    if (number === 0) {
        return '0\'ıncı';
    }
    var x = number % 10;
    var y = number % 100 - x;
    var z = number >= 100 ? 100 : null;
    return number + (suffixes[x] || suffixes[y] || suffixes[z]);
}
var build_format_locale$32 = buildFormatLocale$32;
/**
 * @category Locales
 * @summary Turkish locale.
 * @author Alpcan Aydın [@alpcanaydin]{@link https://github.com/alpcanaydin}
 */
var tr = {
    distanceInWords: build_distance_in_words_locale$32(),
    format: build_format_locale$32()
};
var tr$2 = Object.freeze({
    default: tr,
    __moduleExports: tr
});
function buildDistanceInWordsLocale$34() {
    var distanceInWordsLocale = {
        lessThanXSeconds: {
            one: '1초 미만',
            other: '{{count}}초 미만'
        },
        xSeconds: {
            one: '1초',
            other: '{{count}}초'
        },
        halfAMinute: '30초',
        lessThanXMinutes: {
            one: '1분 미만',
            other: '{{count}}분 미만'
        },
        xMinutes: {
            one: '1분',
            other: '{{count}}분'
        },
        aboutXHours: {
            one: '약 1시간',
            other: '약 {{count}}시간'
        },
        xHours: {
            one: '1시간',
            other: '{{count}}시간'
        },
        xDays: {
            one: '1일',
            other: '{{count}}일'
        },
        aboutXMonths: {
            one: '약 1개월',
            other: '약 {{count}}개월'
        },
        xMonths: {
            one: '1개월',
            other: '{{count}}개월'
        },
        aboutXYears: {
            one: '약 1년',
            other: '약 {{count}}년'
        },
        xYears: {
            one: '1년',
            other: '{{count}}년'
        },
        overXYears: {
            one: '1년 이상',
            other: '{{count}}년 이상'
        },
        almostXYears: {
            one: '거의 1년',
            other: '거의 {{count}}년'
        }
    };
    function localize(token, count, options) {
        options = options || {};
        var result;
        if (typeof distanceInWordsLocale[token] === 'string') {
            result = distanceInWordsLocale[token];
        }
        else if (count === 1) {
            result = distanceInWordsLocale[token].one;
        }
        else {
            result = distanceInWordsLocale[token].other.replace('{{count}}', count);
        }
        if (options.addSuffix) {
            if (options.comparison > 0) {
                return result + ' 후';
            }
            else {
                return result + ' 전';
            }
        }
        return result;
    }
    return {
        localize: localize
    };
}
var build_distance_in_words_locale$34 = buildDistanceInWordsLocale$34;
function buildFormatLocale$34() {
    var months3char = ['1월', '2월', '3월', '4월', '5월', '6월', '7월', '8월', '9월', '10월', '11월', '12월'];
    var monthsFull = ['1월', '2월', '3월', '4월', '5월', '6월', '7월', '8월', '9월', '10월', '11월', '12월'];
    var weekdays2char = ['일', '월', '화', '수', '목', '금', '토'];
    var weekdays3char = ['일', '월', '화', '수', '목', '금', '토'];
    var weekdaysFull = ['일요일', '월요일', '화요일', '수요일', '목요일', '금요일', '토요일'];
    var meridiemUppercase = ['오전', '오후'];
    var meridiemLowercase = ['오전', '오후'];
    var meridiemFull = ['오전', '오후'];
    var formatters = {
        // Month: Jan, Feb, ..., Dec
        'MMM': function (date) {
            return months3char[date.getMonth()];
        },
        // Month: January, February, ..., December
        'MMMM': function (date) {
            return monthsFull[date.getMonth()];
        },
        // Day of week: Su, Mo, ..., Sa
        'dd': function (date) {
            return weekdays2char[date.getDay()];
        },
        // Day of week: Sun, Mon, ..., Sat
        'ddd': function (date) {
            return weekdays3char[date.getDay()];
        },
        // Day of week: Sunday, Monday, ..., Saturday
        'dddd': function (date) {
            return weekdaysFull[date.getDay()];
        },
        // AM, PM
        'A': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemUppercase[1] : meridiemUppercase[0];
        },
        // am, pm
        'a': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemLowercase[1] : meridiemLowercase[0];
        },
        // a.m., p.m.
        'aa': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemFull[1] : meridiemFull[0];
        }
    };
    // Generate ordinal version of formatters: M -> Mo, D -> Do, etc.
    var ordinalFormatters = ['M', 'D', 'DDD', 'd', 'Q', 'W'];
    ordinalFormatters.forEach(function (formatterToken) {
        formatters[formatterToken + 'o'] = function (date, formatters) {
            return ordinal$13(formatters[formatterToken](date));
        };
    });
    return {
        formatters: formatters,
        formattingTokensRegExp: build_formatting_tokens_reg_exp(formatters)
    };
}
function ordinal$13(number) {
    return number + '일';
}
var build_format_locale$34 = buildFormatLocale$34;
/**
 * @category Locales
 * @summary Korean locale.
 * @author Hong Chulju [@angdev]{@link https://github.com/angdev}
 */
var ko = {
    distanceInWords: build_distance_in_words_locale$34(),
    format: build_format_locale$34()
};
var ko$2 = Object.freeze({
    default: ko,
    __moduleExports: ko
});
function buildDistanceInWordsLocale$36() {
    var distanceInWordsLocale = {
        lessThanXSeconds: {
            one: 'λιγότερο από ένα δευτερόλεπτο',
            other: 'λιγότερο από {{count}} δευτερόλεπτα'
        },
        xSeconds: {
            one: '1 δευτερόλεπτο',
            other: '{{count}} δευτερόλεπτα'
        },
        halfAMinute: 'μισό λεπτό',
        lessThanXMinutes: {
            one: 'λιγότερο από ένα λεπτό',
            other: 'λιγότερο από {{count}} λεπτά'
        },
        xMinutes: {
            one: '1 λεπτό',
            other: '{{count}} λεπτά'
        },
        aboutXHours: {
            one: 'περίπου 1 ώρα',
            other: 'περίπου {{count}} ώρες'
        },
        xHours: {
            one: '1 ώρα',
            other: '{{count}} ώρες'
        },
        xDays: {
            one: '1 ημέρα',
            other: '{{count}} ημέρες'
        },
        aboutXMonths: {
            one: 'περίπου 1 μήνας',
            other: 'περίπου {{count}} μήνες'
        },
        xMonths: {
            one: '1 μήνας',
            other: '{{count}} μήνες'
        },
        aboutXYears: {
            one: 'περίπου 1 χρόνο',
            other: 'περίπου {{count}} χρόνια'
        },
        xYears: {
            one: '1 χρόνο',
            other: '{{count}} χρόνια'
        },
        overXYears: {
            one: 'πάνω από 1 χρόνο',
            other: 'πάνω από {{count}} χρόνια'
        },
        almostXYears: {
            one: 'περίπου 1 χρόνο',
            other: 'περίπου {{count}} χρόνια'
        }
    };
    function localize(token, count, options) {
        options = options || {};
        var result;
        if (typeof distanceInWordsLocale[token] === 'string') {
            result = distanceInWordsLocale[token];
        }
        else if (count === 1) {
            result = distanceInWordsLocale[token].one;
        }
        else {
            result = distanceInWordsLocale[token].other.replace('{{count}}', count);
        }
        if (options.addSuffix) {
            if (options.comparison > 0) {
                return 'σε ' + result;
            }
            else {
                return result + ' πρίν';
            }
        }
        return result;
    }
    return {
        localize: localize
    };
}
var build_distance_in_words_locale$36 = buildDistanceInWordsLocale$36;
function buildFormatLocale$36() {
    var months3char = ['Ιαν', 'Φεβ', 'Μαρ', 'Απρ', 'Μαϊ', 'Ιουν', 'Ιουλ', 'Αυγ', 'Σεπ', 'Οκτ', 'Νοε', 'Δεκ'];
    var monthsFull = ['Ιανουάριος', 'Φεβρουάριος', 'Μάρτιος', 'Απρίλιος', 'Μάιος', 'Ιούνιος', 'Ιούλιος', 'Αύγουστος', 'Σεπτέμβριος', 'Οκτώβριος', 'Νοέμβριος', 'Δεκέμβριος'];
    var monthsGenitive = ['Ιανουαρίου', 'Φεβρουαρίου', 'Μαρτίου', 'Απριλίου', 'Μαΐου', 'Ιουνίου', 'Ιουλίου', 'Αυγούστου', 'Σεπτεμβρίου', 'Οκτωβρίου', 'Νοεμβρίου', 'Δεκεμβρίου'];
    var weekdays2char = ['Κυ', 'Δε', 'Τρ', 'Τε', 'Πέ', 'Πα', 'Σά'];
    var weekdays3char = ['Κυρ', 'Δευ', 'Τρί', 'Τετ', 'Πέμ', 'Παρ', 'Σάβ'];
    var weekdaysFull = ['Κυριακή', 'Δευτέρα', 'Τρίτη', 'Τετάρτη', 'Πέμπτη', 'Παρασκευή', 'Σάββατο'];
    var meridiemUppercase = ['ΠΜ', 'ΜΜ'];
    var meridiemLowercase = ['πμ', 'μμ'];
    var meridiemFull = ['π.μ.', 'μ.μ.'];
    var formatters = {
        // Month: Jan, Feb, ..., Dec
        'MMM': function (date) {
            return months3char[date.getMonth()];
        },
        // Month: January, February, ..., December
        'MMMM': function (date) {
            return monthsFull[date.getMonth()];
        },
        // Day of week: Su, Mo, ..., Sa
        'dd': function (date) {
            return weekdays2char[date.getDay()];
        },
        // Day of week: Sun, Mon, ..., Sat
        'ddd': function (date) {
            return weekdays3char[date.getDay()];
        },
        // Day of week: Sunday, Monday, ..., Saturday
        'dddd': function (date) {
            return weekdaysFull[date.getDay()];
        },
        // AM, PM
        'A': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemUppercase[1] : meridiemUppercase[0];
        },
        // am, pm
        'a': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemLowercase[1] : meridiemLowercase[0];
        },
        // a.m., p.m.
        'aa': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemFull[1] : meridiemFull[0];
        }
    };
    // Generate ordinal version of formatters: M -> Mo, D -> Do, etc.
    var ordinalGenders = {
        'M': 'ος',
        'D': 'η',
        'DDD': 'η',
        'd': 'η',
        'Q': 'ο',
        'W': 'η'
    };
    var ordinalKeys = ['M', 'D', 'DDD', 'd', 'Q', 'W'];
    ordinalKeys.forEach(function (formatterToken) {
        formatters[formatterToken + 'o'] = function (date, formatters) {
            return formatters[formatterToken](date) + ordinalGenders[formatterToken];
        };
    });
    // Generate genitive variant of full months
    var formatsWithGenitive = ['D', 'Do', 'DD'];
    formatsWithGenitive.forEach(function (formatterToken) {
        formatters[formatterToken + ' MMMM'] = function (date, commonFormatters) {
            var formatter = formatters[formatterToken] || commonFormatters[formatterToken];
            return formatter(date, commonFormatters) + ' ' + monthsGenitive[date.getMonth()];
        };
    });
    return {
        formatters: formatters,
        formattingTokensRegExp: build_formatting_tokens_reg_exp(formatters)
    };
}
var build_format_locale$36 = buildFormatLocale$36;
/**
 * @category Locales
 * @summary Greek locale.
 * @author Theodoros Orfanidis [@teoulas]{@link https://github.com/teoulas}
 */
var el = {
    distanceInWords: build_distance_in_words_locale$36(),
    format: build_format_locale$36()
};
var el$2 = Object.freeze({
    default: el,
    __moduleExports: el
});
function declensionGroup$1(scheme, count) {
    if (count === 1) {
        return scheme.one;
    }
    if (count >= 2 && count <= 4) {
        return scheme.twoFour;
    }
    // if count === null || count === 0 || count >= 5
    return scheme.other;
}
function declension$2(scheme, count, time) {
    var group = declensionGroup$1(scheme, count);
    var finalText = group[time] || group;
    return finalText.replace('{{count}}', count);
}
function extractPreposition(token) {
    var result = ['lessThan', 'about', 'over', 'almost'].filter(function (preposition) {
        return !!token.match(new RegExp('^' + preposition));
    });
    return result[0];
}
function prefixPreposition(preposition) {
    var translation = '';
    if (preposition === 'almost') {
        translation = 'takmer';
    }
    if (preposition === 'about') {
        translation = 'približne';
    }
    return translation.length > 0 ? translation + ' ' : '';
}
function suffixPreposition(preposition) {
    var translation = '';
    if (preposition === 'lessThan') {
        translation = 'menej než';
    }
    if (preposition === 'over') {
        translation = 'viac než';
    }
    return translation.length > 0 ? translation + ' ' : '';
}
function lowercaseFirstLetter(string) {
    return string.charAt(0).toLowerCase() + string.slice(1);
}
function buildDistanceInWordsLocale$38() {
    var distanceInWordsLocale = {
        xSeconds: {
            one: {
                regular: 'sekunda',
                past: 'sekundou',
                future: 'sekundu'
            },
            twoFour: {
                regular: '{{count}} sekundy',
                past: '{{count}} sekundami',
                future: '{{count}} sekundy'
            },
            other: {
                regular: '{{count}} sekúnd',
                past: '{{count}} sekundami',
                future: '{{count}} sekúnd'
            }
        },
        halfAMinute: {
            other: {
                regular: 'pol minúty',
                past: 'pol minútou',
                future: 'pol minúty'
            }
        },
        xMinutes: {
            one: {
                regular: 'minúta',
                past: 'minútou',
                future: 'minútu'
            },
            twoFour: {
                regular: '{{count}} minúty',
                past: '{{count}} minútami',
                future: '{{count}} minúty'
            },
            other: {
                regular: '{{count}} minút',
                past: '{{count}} minútami',
                future: '{{count}} minút'
            }
        },
        xHours: {
            one: {
                regular: 'hodina',
                past: 'hodinou',
                future: 'hodinu'
            },
            twoFour: {
                regular: '{{count}} hodiny',
                past: '{{count}} hodinami',
                future: '{{count}} hodiny'
            },
            other: {
                regular: '{{count}} hodín',
                past: '{{count}} hodinami',
                future: '{{count}} hodín'
            }
        },
        xDays: {
            one: {
                regular: 'deň',
                past: 'dňom',
                future: 'deň'
            },
            twoFour: {
                regular: '{{count}} dni',
                past: '{{count}} dňami',
                future: '{{count}} dni'
            },
            other: {
                regular: '{{count}} dní',
                past: '{{count}} dňami',
                future: '{{count}} dní'
            }
        },
        xMonths: {
            one: {
                regular: 'mesiac',
                past: 'mesiacom',
                future: 'mesiac'
            },
            twoFour: {
                regular: '{{count}} mesiace',
                past: '{{count}} mesiacmi',
                future: '{{count}} mesiace'
            },
            other: {
                regular: '{{count}} mesiacov',
                past: '{{count}} mesiacmi',
                future: '{{count}} mesiacov'
            }
        },
        xYears: {
            one: {
                regular: 'rok',
                past: 'rokom',
                future: 'rok'
            },
            twoFour: {
                regular: '{{count}} roky',
                past: '{{count}} rokmi',
                future: '{{count}} roky'
            },
            other: {
                regular: '{{count}} rokov',
                past: '{{count}} rokmi',
                future: '{{count}} rokov'
            }
        }
    };
    function localize(token, count, options) {
        options = options || {};
        var preposition = extractPreposition(token) || '';
        var key = lowercaseFirstLetter(token.substring(preposition.length));
        var scheme = distanceInWordsLocale[key];
        if (!options.addSuffix) {
            return prefixPreposition(preposition) + suffixPreposition(preposition) + declension$2(scheme, count, 'regular');
        }
        if (options.comparison > 0) {
            return prefixPreposition(preposition) + 'za ' + suffixPreposition(preposition) + declension$2(scheme, count, 'future');
        }
        else {
            return prefixPreposition(preposition) + 'pred ' + suffixPreposition(preposition) + declension$2(scheme, count, 'past');
        }
    }
    return {
        localize: localize
    };
}
var build_distance_in_words_locale$38 = buildDistanceInWordsLocale$38;
function buildFormatLocale$38() {
    var months3char = ['jan', 'feb', 'mar', 'apr', 'máj', 'jún', 'júl', 'aug', 'sep', 'okt', 'nov', 'dec'];
    var monthsFull = ['január', 'február', 'marec', 'apríl', 'máj', 'jún', 'júl', 'august', 'september', 'október', 'november', 'december'];
    var weekdays2char = ['ne', 'po', 'ut', 'st', 'št', 'pi', 'so'];
    var weekdays3char = ['neď', 'pon', 'uto', 'str', 'štv', 'pia', 'sob'];
    var weekdaysFull = ['nedeľa', 'pondelok', 'utorok', 'streda', 'štvrtok', 'piatok', 'sobota'];
    var meridiemUppercase = ['AM', 'PM'];
    var meridiemLowercase = ['am', 'pm'];
    var meridiemFull = ['a.m.', 'p.m.'];
    var formatters = {
        // Month: jan, feb, ..., dec
        'MMM': function (date) {
            return months3char[date.getMonth()];
        },
        // Month: január, február, ..., december
        'MMMM': function (date) {
            return monthsFull[date.getMonth()];
        },
        // Day of week: ne, po, ..., so
        'dd': function (date) {
            return weekdays2char[date.getDay()];
        },
        // Day of week: neď, pon, ..., sob
        'ddd': function (date) {
            return weekdays3char[date.getDay()];
        },
        // Day of week: neďeľa, pondelok, ..., sobota
        'dddd': function (date) {
            return weekdaysFull[date.getDay()];
        },
        // AM, PM
        'A': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemUppercase[1] : meridiemUppercase[0];
        },
        // am, pm
        'a': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemLowercase[1] : meridiemLowercase[0];
        },
        // a.m., p.m.
        'aa': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemFull[1] : meridiemFull[0];
        }
    };
    // Generate ordinal version of formatters: M -> Mo, D -> Do, etc.
    var ordinalFormatters = ['M', 'D', 'DDD', 'd', 'Q', 'W'];
    ordinalFormatters.forEach(function (formatterToken) {
        formatters[formatterToken + 'o'] = function (date, formatters) {
            return ordinal$14(formatters[formatterToken](date));
        };
    });
    return {
        formatters: formatters,
        formattingTokensRegExp: build_formatting_tokens_reg_exp(formatters)
    };
}
function ordinal$14(number) {
    return number + '.';
}
var build_format_locale$38 = buildFormatLocale$38;
/**
 * @category Locales
 * @summary Slovak locale.
 * @author Marek Suscak [@mareksuscak]{@link https://github.com/mareksuscak}
 */
var sk = {
    distanceInWords: build_distance_in_words_locale$38(),
    format: build_format_locale$38()
};
var sk$2 = Object.freeze({
    default: sk,
    __moduleExports: sk
});
function buildDistanceInWordsLocale$40() {
    var distanceInWordsLocale = {
        lessThanXSeconds: {
            one: 'mas maliit sa isang segundo',
            other: 'mas maliit sa {{count}} segundo'
        },
        xSeconds: {
            one: '1 segundo',
            other: '{{count}} segundo'
        },
        halfAMinute: 'kalahating minuto',
        lessThanXMinutes: {
            one: 'mas maliit sa isang minuto',
            other: 'mas maliit sa {{count}} minuto'
        },
        xMinutes: {
            one: '1 minuto',
            other: '{{count}} minuto'
        },
        aboutXHours: {
            one: 'mga 1 oras',
            other: 'mga {{count}} oras'
        },
        xHours: {
            one: '1 oras',
            other: '{{count}} oras'
        },
        xDays: {
            one: '1 araw',
            other: '{{count}} araw'
        },
        aboutXMonths: {
            one: 'mga 1 buwan',
            other: 'mga {{count}} buwan'
        },
        xMonths: {
            one: '1 buwan',
            other: '{{count}} buwan'
        },
        aboutXYears: {
            one: 'mga 1 taon',
            other: 'mga {{count}} taon'
        },
        xYears: {
            one: '1 taon',
            other: '{{count}} taon'
        },
        overXYears: {
            one: 'higit sa 1 taon',
            other: 'higit sa {{count}} taon'
        },
        almostXYears: {
            one: 'halos 1 taon',
            other: 'halos {{count}} taon'
        }
    };
    function localize(token, count, options) {
        options = options || {};
        var result;
        if (typeof distanceInWordsLocale[token] === 'string') {
            result = distanceInWordsLocale[token];
        }
        else if (count === 1) {
            result = distanceInWordsLocale[token].one;
        }
        else {
            result = distanceInWordsLocale[token].other.replace('{{count}}', count);
        }
        if (options.addSuffix) {
            if (options.comparison > 0) {
                return 'sa loob ng ' + result;
            }
            else {
                return result + ' ang nakalipas';
            }
        }
        return result;
    }
    return {
        localize: localize
    };
}
var build_distance_in_words_locale$40 = buildDistanceInWordsLocale$40;
function buildFormatLocale$40() {
    var months3char = ['Ene', 'Peb', 'Mar', 'Abr', 'May', 'Hun', 'Hul', 'Ago', 'Set', 'Okt', 'Nob', 'Dis'];
    var monthsFull = ['Enero', 'Pebrero', 'Marso', 'Abril', 'Mayo', 'Hunyo', 'Hulyo', 'Agosto', 'Setyembre', 'Oktubre', 'Nobyembre', 'Disyembre'];
    var weekdays2char = ['Li', 'Lu', 'Ma', 'Mi', 'Hu', 'Bi', 'Sa'];
    var weekdays3char = ['Lin', 'Lun', 'Mar', 'Miy', 'Huw', 'Biy', 'Sab'];
    var weekdaysFull = ['Linggo', 'Lunes', 'Martes', 'Miyerkules', 'Huwebes', 'Biyernes', 'Sabado'];
    var meridiemUppercase = ['NU', 'NT', 'NH', 'NG'];
    var meridiemLowercase = ['nu', 'nt', 'nh', 'ng'];
    var meridiemFull = ['ng umaga', 'ng tanghali', 'ng hapon', 'ng gabi'];
    var formatters = {
        // Month: Jan, Feb, ..., Dec
        'MMM': function (date) {
            return months3char[date.getMonth()];
        },
        // Month: January, February, ..., December
        'MMMM': function (date) {
            return monthsFull[date.getMonth()];
        },
        // Day of week: Su, Mo, ..., Sa
        'dd': function (date) {
            return weekdays2char[date.getDay()];
        },
        // Day of week: Sun, Mon, ..., Sat
        'ddd': function (date) {
            return weekdays3char[date.getDay()];
        },
        // Day of week: Sunday, Monday, ..., Saturday
        'dddd': function (date) {
            return weekdaysFull[date.getDay()];
        },
        // AM, PM
        'A': function (date) {
            if (date.getHours() > 12) {
                var modulo = date.getHours() % 12;
                if (modulo < 6) {
                    return meridiemUppercase[2];
                }
                else {
                    return meridiemUppercase[3];
                }
            }
            else if (date.getHours() < 12) {
                return meridiemUppercase[0];
            }
            else {
                return meridiemUppercase[1];
            }
        },
        // am, pm
        'a': function (date) {
            if (date.getHours() > 12) {
                var modulo = date.getHours() % 12;
                if (modulo < 6) {
                    return meridiemLowercase[2];
                }
                else {
                    return meridiemLowercase[3];
                }
            }
            else if (date.getHours() < 12) {
                return meridiemLowercase[0];
            }
            else {
                return meridiemLowercase[1];
            }
        },
        // a.m., p.m.
        'aa': function (date) {
            if (date.getHours() > 12) {
                var modulo = date.getHours() % 12;
                if (modulo < 6) {
                    return meridiemFull[2];
                }
                else {
                    return meridiemFull[3];
                }
            }
            else if (date.getHours() < 12) {
                return meridiemFull[0];
            }
            else {
                return meridiemFull[1];
            }
        }
    };
    // Generate ordinal version of formatters: M -> Mo, D -> Do, etc.
    var ordinalFormatters = ['M', 'D', 'DDD', 'd', 'Q', 'W'];
    ordinalFormatters.forEach(function (formatterToken) {
        formatters[formatterToken + 'o'] = function (date, formatters) {
            return ordinal$15(formatters[formatterToken](date));
        };
    });
    return {
        formatters: formatters,
        formattingTokensRegExp: build_formatting_tokens_reg_exp(formatters)
    };
}
function ordinal$15(number) {
    return 'ika-' + number;
}
var build_format_locale$40 = buildFormatLocale$40;
/**
 * @category Locales
 * @summary Filipino locale.
 * @author Ian De La Cruz [@RIanDeLaCruz]{@link https://github.com/RIanDeLaCruz}
 */
var fil = {
    distanceInWords: build_distance_in_words_locale$40(),
    format: build_format_locale$40()
};
var fil$2 = Object.freeze({
    default: fil,
    __moduleExports: fil
});
function buildDistanceInWordsLocale$42() {
    var distanceInWordsLocale = {
        lessThanXSeconds: {
            one: 'mindre end et sekund',
            other: 'mindre end {{count}} sekunder'
        },
        xSeconds: {
            one: '1 sekund',
            other: '{{count}} sekunder'
        },
        halfAMinute: 'et halvt minut',
        lessThanXMinutes: {
            one: 'mindre end et minut',
            other: 'mindre end {{count}} minutter'
        },
        xMinutes: {
            one: '1 minut',
            other: '{{count}} minutter'
        },
        aboutXHours: {
            one: 'cirka 1 time',
            other: 'cirka {{count}} timer'
        },
        xHours: {
            one: '1 time',
            other: '{{count}} timer'
        },
        xDays: {
            one: '1 dag',
            other: '{{count}} dage'
        },
        aboutXMonths: {
            one: 'cirka 1 måned',
            other: 'cirka {{count}} måneder'
        },
        xMonths: {
            one: '1 måned',
            other: '{{count}} måneder'
        },
        aboutXYears: {
            one: 'cirka 1 år',
            other: 'cirka {{count}} år'
        },
        xYears: {
            one: '1 år',
            other: '{{count}} år'
        },
        overXYears: {
            one: 'over 1 år',
            other: 'over {{count}} år'
        },
        almostXYears: {
            one: 'næsten 1 år',
            other: 'næsten {{count}} år'
        }
    };
    function localize(token, count, options) {
        options = options || {};
        var result;
        if (typeof distanceInWordsLocale[token] === 'string') {
            result = distanceInWordsLocale[token];
        }
        else if (count === 1) {
            result = distanceInWordsLocale[token].one;
        }
        else {
            result = distanceInWordsLocale[token].other.replace('{{count}}', count);
        }
        if (options.addSuffix) {
            if (options.comparison > 0) {
                return 'om ' + result;
            }
            else {
                return result + ' siden';
            }
        }
        return result;
    }
    return {
        localize: localize
    };
}
var build_distance_in_words_locale$42 = buildDistanceInWordsLocale$42;
function buildFormatLocale$42() {
    var months3char = ['jan', 'feb', 'mar', 'apr', 'maj', 'jun', 'jul', 'aug', 'sep', 'okt', 'nov', 'dec'];
    var monthsFull = ['januar', 'februar', 'marts', 'april', 'maj', 'juni', 'juli', 'august', 'september', 'oktober', 'november', 'december'];
    var weekdays2char = ['sø', 'ma', 'ti', 'on', 'to', 'fr', 'lø'];
    var weekdays3char = ['søn', 'man', 'tir', 'ons', 'tor', 'fre', 'lør'];
    var weekdaysFull = ['søndag', 'mandag', 'tirsdag', 'onsdag', 'torsdag', 'fredag', 'lørdag'];
    var meridiemUppercase = ['AM', 'PM'];
    var meridiemLowercase = ['am', 'pm'];
    var meridiemFull = ['a.m.', 'p.m.'];
    var formatters = {
        // Month: Jan, Feb, ..., Dec
        'MMM': function (date) {
            return months3char[date.getMonth()];
        },
        // Month: January, February, ..., December
        'MMMM': function (date) {
            return monthsFull[date.getMonth()];
        },
        // Day of week: Su, Mo, ..., Sa
        'dd': function (date) {
            return weekdays2char[date.getDay()];
        },
        // Day of week: Sun, Mon, ..., Sat
        'ddd': function (date) {
            return weekdays3char[date.getDay()];
        },
        // Day of week: Sunday, Monday, ..., Saturday
        'dddd': function (date) {
            return weekdaysFull[date.getDay()];
        },
        // AM, PM
        'A': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemUppercase[1] : meridiemUppercase[0];
        },
        // am, pm
        'a': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemLowercase[1] : meridiemLowercase[0];
        },
        // a.m., p.m.
        'aa': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemFull[1] : meridiemFull[0];
        }
    };
    // Generate ordinal version of formatters: M -> Mo, D -> Do, etc.
    var ordinalFormatters = ['M', 'D', 'DDD', 'd', 'Q', 'W'];
    ordinalFormatters.forEach(function (formatterToken) {
        formatters[formatterToken + 'o'] = function (date, formatters) {
            return ordinal$16(formatters[formatterToken](date));
        };
    });
    return {
        formatters: formatters,
        formattingTokensRegExp: build_formatting_tokens_reg_exp(formatters)
    };
}
function ordinal$16(number) {
    return number + '.';
}
var build_format_locale$42 = buildFormatLocale$42;
/**
 * @category Locales
 * @summary Danish locale.
 * @author Anders B. Hansen [@Andersbiha]{@link https://github.com/Andersbiha}
 * @author [@kgram]{@link https://github.com/kgram}
 */
var da = {
    distanceInWords: build_distance_in_words_locale$42(),
    format: build_format_locale$42()
};
var da$2 = Object.freeze({
    default: da,
    __moduleExports: da
});
function buildDistanceInWordsLocale$44() {
    var distanceInWordsLocale = {
        lessThanXSeconds: {
            one: 'minna en 1 sekúnda',
            other: 'minna en {{count}} sekúndur'
        },
        xSeconds: {
            one: '1 sekúnda',
            other: '{{count}} sekúndur'
        },
        halfAMinute: 'hálf mínúta',
        lessThanXMinutes: {
            one: 'minna en 1 mínúta',
            other: 'minna en {{count}} mínútur'
        },
        xMinutes: {
            one: '1 mínúta',
            other: '{{count}} mínútur'
        },
        aboutXHours: {
            one: 'u.þ.b. 1 klukkustund',
            other: 'u.þ.b. {{count}} klukkustundir'
        },
        xHours: {
            one: '1 klukkustund',
            other: '{{count}} klukkustundir'
        },
        xDays: {
            one: '1 dagur',
            other: '{{count}} dagar'
        },
        aboutXMonths: {
            one: 'u.þ.b. 1 mánuður',
            other: 'u.þ.b. {{count}} mánuðir'
        },
        xMonths: {
            one: '1 mánuður',
            other: '{{count}} mánuðir'
        },
        aboutXYears: {
            one: 'u.þ.b. 1 ár',
            other: 'u.þ.b. {{count}} ár'
        },
        xYears: {
            one: '1 ár',
            other: '{{count}} ár'
        },
        overXYears: {
            one: 'meira en 1 ár',
            other: 'meira en {{count}} ár'
        },
        almostXYears: {
            one: 'næstum 1 ár',
            other: 'næstum {{count}} ár'
        }
    };
    function localize(token, count, options) {
        options = options || {};
        var result;
        if (typeof distanceInWordsLocale[token] === 'string') {
            result = distanceInWordsLocale[token];
        }
        else if (count === 1) {
            result = distanceInWordsLocale[token].one;
        }
        else {
            result = distanceInWordsLocale[token].other.replace('{{count}}', count);
        }
        if (options.addSuffix) {
            if (options.comparison > 0) {
                return 'í ' + result;
            }
            else {
                return result + ' síðan';
            }
        }
        return result;
    }
    return {
        localize: localize
    };
}
var build_distance_in_words_locale$44 = buildDistanceInWordsLocale$44;
function buildFormatLocale$44() {
    var months3char = ['jan', 'feb', 'mar', 'apr', 'maí', 'jún', 'júl', 'ágú', 'sep', 'okt', 'nóv', 'des'];
    var monthsFull = ['janúar', 'febrúar', 'mars', 'apríl', 'maí', 'júní', 'júlí', 'ágúst', 'september', 'október', 'nóvember', 'desember'];
    var weekdays2char = ['su', 'má', 'þr', 'mi', 'fi', 'fö', 'la'];
    var weekdays3char = ['sun', 'mán', 'þri', 'mið', 'fim', 'fös', 'lau'];
    var weekdaysFull = ['sunnudaginn', 'mánudaginn', 'þriðjudaginn', 'miðvikudaginn', 'fimmtudaginn', 'föstudaginn', 'laugardaginn'];
    var meridiemUppercase = ['AM', 'PM'];
    var meridiemLowercase = ['am', 'pm'];
    var meridiemFull = ['a.m.', 'p.m.'];
    var formatters = {
        // Month: Jan, Feb, ..., Dec
        'MMM': function (date) {
            return months3char[date.getMonth()];
        },
        // Month: January, February, ..., December
        'MMMM': function (date) {
            return monthsFull[date.getMonth()];
        },
        // Day of week: Su, Mo, ..., Sa
        'dd': function (date) {
            return weekdays2char[date.getDay()];
        },
        // Day of week: Sun, Mon, ..., Sat
        'ddd': function (date) {
            return weekdays3char[date.getDay()];
        },
        // Day of week: Sunday, Monday, ..., Saturday
        'dddd': function (date) {
            return weekdaysFull[date.getDay()];
        },
        // AM, PM
        'A': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemUppercase[1] : meridiemUppercase[0];
        },
        // am, pm
        'a': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemLowercase[1] : meridiemLowercase[0];
        },
        // a.m., p.m.
        'aa': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemFull[1] : meridiemFull[0];
        }
    };
    // Generate ordinal version of formatters: M -> Mo, D -> Do, etc.
    var ordinalFormatters = ['M', 'D', 'DDD', 'd', 'Q', 'W'];
    ordinalFormatters.forEach(function (formatterToken) {
        formatters[formatterToken + 'o'] = function (date, formatters) {
            return ordinal$17(formatters[formatterToken](date));
        };
    });
    return {
        formatters: formatters,
        formattingTokensRegExp: build_formatting_tokens_reg_exp(formatters)
    };
}
function ordinal$17(number) {
    return '' + number;
}
var build_format_locale$44 = buildFormatLocale$44;
/**
 * @category Locales
 * @summary Icelandic locale.
 * @author Derek Blank [@derekblank]{@link https://github.com/derekblank}
 */
var is = {
    distanceInWords: build_distance_in_words_locale$44(),
    format: build_format_locale$44()
};
var is$2 = Object.freeze({
    default: is,
    __moduleExports: is
});
function buildDistanceInWordsLocale$46() {
    function futureSeconds(text) {
        return text.replace(/sekuntia?/, 'sekunnin');
    }
    function futureMinutes(text) {
        return text.replace(/minuuttia?/, 'minuutin');
    }
    function futureHours(text) {
        return text.replace(/tuntia?/, 'tunnin');
    }
    function futureDays(text) {
        return text.replace(/päivää?/, 'päivän');
    }
    function futureMonths(text) {
        return text.replace(/(kuukausi|kuukautta)/, 'kuukauden');
    }
    function futureYears(text) {
        return text.replace(/(vuosi|vuotta)/, 'vuoden');
    }
    var distanceInWordsLocale = {
        lessThanXSeconds: {
            one: 'alle sekunti',
            other: 'alle {{count}} sekuntia',
            futureTense: futureSeconds
        },
        xSeconds: {
            one: 'sekunti',
            other: '{{count}} sekuntia',
            futureTense: futureSeconds
        },
        halfAMinute: {
            one: 'puoli minuuttia',
            other: 'puoli minuuttia',
            futureTense: function (text) {
                return 'puolen minuutin';
            }
        },
        lessThanXMinutes: {
            one: 'alle minuutti',
            other: 'alle {{count}} minuuttia',
            futureTense: futureMinutes
        },
        xMinutes: {
            one: 'minuutti',
            other: '{{count}} minuuttia',
            futureTense: futureMinutes
        },
        aboutXHours: {
            one: 'noin tunti',
            other: 'noin {{count}} tuntia',
            futureTense: futureHours
        },
        xHours: {
            one: 'tunti',
            other: '{{count}} tuntia',
            futureTense: futureHours
        },
        xDays: {
            one: 'päivä',
            other: '{{count}} päivää',
            futureTense: futureDays
        },
        aboutXMonths: {
            one: 'noin kuukausi',
            other: 'noin {{count}} kuukautta',
            futureTense: futureMonths
        },
        xMonths: {
            one: 'kuukausi',
            other: '{{count}} kuukautta',
            futureTense: futureMonths
        },
        aboutXYears: {
            one: 'noin vuosi',
            other: 'noin {{count}} vuotta',
            futureTense: futureYears
        },
        xYears: {
            one: 'vuosi',
            other: '{{count}} vuotta',
            futureTense: futureYears
        },
        overXYears: {
            one: 'yli vuosi',
            other: 'yli {{count}} vuotta',
            futureTense: futureYears
        },
        almostXYears: {
            one: 'lähes vuosi',
            other: 'lähes {{count}} vuotta',
            futureTense: futureYears
        }
    };
    function localize(token, count, options) {
        options = options || {};
        var distance = distanceInWordsLocale[token];
        var result = count === 1 ? distance.one : distance.other.replace('{{count}}', count);
        if (options.addSuffix) {
            if (options.comparison > 0) {
                return distance.futureTense(result) + ' kuluttua';
            }
            else {
                return result + ' sitten';
            }
        }
        return result;
    }
    return {
        localize: localize
    };
}
var build_distance_in_words_locale$46 = buildDistanceInWordsLocale$46;
function buildFormatLocale$46() {
    var months3char = ['tammi', 'helmi', 'maalis', 'huhti', 'touko', 'kesä', 'heinä', 'elo', 'syys', 'loka', 'marras', 'joulu'];
    var monthsFull = ['tammikuu', 'helmikuu', 'maaliskuu', 'huhtikuu', 'toukokuu', 'kesäkuu', 'heinäkuu', 'elokuu', 'syyskuu', 'lokakuu', 'marraskuu', 'joulukuu'];
    var weekdays2char = ['su', 'ma', 'ti', 'ke', 'to', 'pe', 'la'];
    var weekdaysFull = ['sunnuntai', 'maanantai', 'tiistai', 'keskiviikko', 'torstai', 'perjantai', 'lauantai'];
    // In Finnish `a.m.` / `p.m.` are virtually never used, but it seems `AP` (aamupäivä) / `IP` (iltapäivä) are acknowleded terms:
    // https://fi.wikipedia.org/wiki/24_tunnin_kello
    function meridiem(date) {
        return date.getHours() < 12 ? 'AP' : 'IP';
    }
    var formatters = {
        // Month: Jan, Feb, ..., Dec
        'MMM': function (date) {
            return months3char[date.getMonth()];
        },
        // Month: January, February, ..., December
        'MMMM': function (date) {
            return monthsFull[date.getMonth()];
        },
        // Day of week: Su, Mo, ..., Sa
        'dd': function (date) {
            return weekdays2char[date.getDay()];
        },
        // Day of week: Sun, Mon, ..., Sat
        'ddd': function (date) {
            // Finnish doesn't use two-char weekdays
            return weekdays2char[date.getDay()];
        },
        // Day of week: Sunday, Monday, ..., Saturday
        'dddd': function (date) {
            return weekdaysFull[date.getDay()];
        },
        // AM, PM
        'A': meridiem,
        // am, pm
        'a': meridiem,
        // a.m., p.m.
        'aa': meridiem
    };
    // Generate ordinal version of formatters: M -> Mo, D -> Do, etc.
    var ordinalFormatters = ['M', 'D', 'DDD', 'd', 'Q', 'W'];
    ordinalFormatters.forEach(function (formatterToken) {
        formatters[formatterToken + 'o'] = function (date, formatters) {
            return formatters[formatterToken](date).toString() + '.';
        };
    });
    return {
        formatters: formatters,
        formattingTokensRegExp: build_formatting_tokens_reg_exp(formatters)
    };
}
var build_format_locale$46 = buildFormatLocale$46;
/**
 * @category Locales
 * @summary Finnish locale.
 * @author Pyry-Samuli Lahti [@Pyppe]{@link https://github.com/Pyppe}
 */
var fi = {
    distanceInWords: build_distance_in_words_locale$46(),
    format: build_format_locale$46()
};
var fi$2 = Object.freeze({
    default: fi,
    __moduleExports: fi
});
function buildDistanceInWordsLocale$48() {
    var distanceInWordsLocale = {
        lessThanXSeconds: {
            one: 'น้อยกว่า 1 วินาที',
            other: 'น้อยกว่า {{count}} วินาที'
        },
        xSeconds: {
            one: '1 วินาที',
            other: '{{count}} วินาที'
        },
        halfAMinute: 'ครึ่งนาที',
        lessThanXMinutes: {
            one: 'น้อยกว่า 1 นาที',
            other: 'น้อยกว่า {{count}} นาที'
        },
        xMinutes: {
            one: '1 นาที',
            other: '{{count}} นาที'
        },
        aboutXHours: {
            one: 'ประมาณ 1 ชั่วโมง',
            other: 'ประมาณ {{count}} ชั่วโมง'
        },
        xHours: {
            one: '1 ชั่วโมง',
            other: '{{count}} ชั่วโมง'
        },
        xDays: {
            one: '1 วัน',
            other: '{{count}} วัน'
        },
        aboutXMonths: {
            one: 'ประมาณ 1 เดือน',
            other: 'ประมาณ {{count}} เดือน'
        },
        xMonths: {
            one: '1 เดือน',
            other: '{{count}} เดือน'
        },
        aboutXYears: {
            one: 'ประมาณ 1 ปี',
            other: 'ประมาณ {{count}} ปี'
        },
        xYears: {
            one: '1 ปี',
            other: '{{count}} ปี'
        },
        overXYears: {
            one: 'มากกว่า 1 ปี',
            other: 'มากกว่า {{count}} ปี'
        },
        almostXYears: {
            one: 'เกือบ 1 ปี',
            other: 'เกือบ {{count}} ปี'
        }
    };
    function localize(token, count, options) {
        options = options || {};
        var result;
        if (typeof distanceInWordsLocale[token] === 'string') {
            result = distanceInWordsLocale[token];
        }
        else if (count === 1) {
            result = distanceInWordsLocale[token].one;
        }
        else {
            result = distanceInWordsLocale[token].other.replace('{{count}}', count);
        }
        if (options.addSuffix) {
            if (options.comparison > 0) {
                if (token === 'halfAMinute') {
                    return 'ใน' + result;
                }
                else {
                    return 'ใน ' + result;
                }
            }
            else {
                return result + 'ที่ผ่านมา';
            }
        }
        return result;
    }
    return {
        localize: localize
    };
}
var build_distance_in_words_locale$48 = buildDistanceInWordsLocale$48;
function buildFormatLocale$48() {
    var months3char = ['ม.ค.', 'ก.พ.', 'มี.ค.', 'เม.ย.', 'พ.ค.', 'มิ.ย.', 'ก.ค.', 'ส.ค.', 'ก.ย.', 'ต.ค.', 'พ.ย.', 'ธ.ค.'];
    var monthsFull = ['มกราคาม', 'กุมภาพันธ์', 'มีนาคม', 'เมษายน', 'พฤษภาคม', 'มิถุนายน', 'กรกฎาคม', 'สิงหาคม', 'กันยายน', 'ตุลาคม', 'พฤศจิกายน', 'ธันวาคม'];
    var weekdays2char = ['อา.', 'จ.', 'อ.', 'พ.', 'พฤ.', 'ศ.', 'ส.'];
    var weekdays3char = ['อา.', 'จ.', 'อ.', 'พ.', 'พฤ.', 'ศ.', 'ส.'];
    var weekdaysFull = ['อาทิตย์', 'จันทร์', 'อังคาร', 'พุธ', 'พฤหัสบดี', 'ศุกร์', 'เสาร์'];
    var meridiemUppercase = ['น.'];
    var meridiemLowercase = ['น.'];
    var meridiemFull = ['นาฬิกา'];
    var formatters = {
        // Month: Jan, Feb, ..., Dec
        'MMM': function (date) {
            return months3char[date.getMonth()];
        },
        // Month: January, February, ..., December
        'MMMM': function (date) {
            return monthsFull[date.getMonth()];
        },
        // Day of week: Su, Mo, ..., Sa
        'dd': function (date) {
            return weekdays2char[date.getDay()];
        },
        // Day of week: Sun, Mon, ..., Sat
        'ddd': function (date) {
            return weekdays3char[date.getDay()];
        },
        // Day of week: Sunday, Monday, ..., Saturday
        'dddd': function (date) {
            return weekdaysFull[date.getDay()];
        },
        // AM, PM
        'A': function (date) {
            return meridiemUppercase[0];
        },
        // am, pm
        'a': function (date) {
            return meridiemLowercase[0];
        },
        // a.m., p.m.
        'aa': function (date) {
            return meridiemFull[0];
        }
    };
    return {
        formatters: formatters,
        formattingTokensRegExp: build_formatting_tokens_reg_exp(formatters)
    };
}
var build_format_locale$48 = buildFormatLocale$48;
/**
 * @category Locales
 * @summary Thai locale.
 * @author Athiwat Hirunworawongkun [@athivvat]{@link https://github.com/athivvat}
 */
var th = {
    distanceInWords: build_distance_in_words_locale$48(),
    format: build_format_locale$48()
};
var th$2 = Object.freeze({
    default: th,
    __moduleExports: th
});
function buildDistanceInWordsLocale$50() {
    var distanceInWordsLocale = {
        lessThanXSeconds: {
            one: {
                standalone: 'manje od 1 sekunde',
                withPrepositionAgo: 'manje od 1 sekunde',
                withPrepositionIn: 'manje od 1 sekundu'
            },
            dual: 'manje od {{count}} sekunde',
            other: 'manje od {{count}} sekundi'
        },
        xSeconds: {
            one: {
                standalone: '1 sekunda',
                withPrepositionAgo: '1 sekunde',
                withPrepositionIn: '1 sekundu'
            },
            dual: '{{count}} sekunde',
            other: '{{count}} sekundi'
        },
        halfAMinute: 'pola minute',
        lessThanXMinutes: {
            one: {
                standalone: 'manje od 1 minute',
                withPrepositionAgo: 'manje od 1 minute',
                withPrepositionIn: 'manje od 1 minutu'
            },
            dual: 'manje od {{count}} minute',
            other: 'manje od {{count}} minuta'
        },
        xMinutes: {
            one: {
                standalone: '1 minuta',
                withPrepositionAgo: '1 minute',
                withPrepositionIn: '1 minutu'
            },
            dual: '{{count}} minute',
            other: '{{count}} minuta'
        },
        aboutXHours: {
            one: {
                standalone: 'oko 1 sat',
                withPrepositionAgo: 'oko 1 sat',
                withPrepositionIn: 'oko 1 sat'
            },
            dual: 'oko {{count}} sata',
            other: 'oko {{count}} sati'
        },
        xHours: {
            one: {
                standalone: '1 sat',
                withPrepositionAgo: '1 sat',
                withPrepositionIn: '1 sat'
            },
            dual: '{{count}} sata',
            other: '{{count}} sati'
        },
        xDays: {
            one: {
                standalone: '1 dan',
                withPrepositionAgo: '1 dan',
                withPrepositionIn: '1 dan'
            },
            dual: '{{count}} dana',
            other: '{{count}} dana'
        },
        aboutXMonths: {
            one: {
                standalone: 'oko 1 mjesec',
                withPrepositionAgo: 'oko 1 mjesec',
                withPrepositionIn: 'oko 1 mjesec'
            },
            dual: 'oko {{count}} mjeseca',
            other: 'oko {{count}} mjeseci'
        },
        xMonths: {
            one: {
                standalone: '1 mjesec',
                withPrepositionAgo: '1 mjesec',
                withPrepositionIn: '1 mjesec'
            },
            dual: '{{count}} mjeseca',
            other: '{{count}} mjeseci'
        },
        aboutXYears: {
            one: {
                standalone: 'oko 1 godinu',
                withPrepositionAgo: 'oko 1 godinu',
                withPrepositionIn: 'oko 1 godinu'
            },
            dual: 'oko {{count}} godine',
            other: 'oko {{count}} godina'
        },
        xYears: {
            one: {
                standalone: '1 godina',
                withPrepositionAgo: '1 godine',
                withPrepositionIn: '1 godinu'
            },
            dual: '{{count}} godine',
            other: '{{count}} godina'
        },
        overXYears: {
            one: {
                standalone: 'preko 1 godinu',
                withPrepositionAgo: 'preko 1 godinu',
                withPrepositionIn: 'preko 1 godinu'
            },
            dual: 'preko {{count}} godine',
            other: 'preko {{count}} godina'
        },
        almostXYears: {
            one: {
                standalone: 'gotovo 1 godinu',
                withPrepositionAgo: 'gotovo 1 godinu',
                withPrepositionIn: 'gotovo 1 godinu'
            },
            dual: 'gotovo {{count}} godine',
            other: 'gotovo {{count}} godina'
        }
    };
    function localize(token, count, options) {
        options = options || {};
        var result;
        if (typeof distanceInWordsLocale[token] === 'string') {
            result = distanceInWordsLocale[token];
        }
        else if (count === 1) {
            if (options.addSuffix) {
                if (options.comparison > 0) {
                    result = distanceInWordsLocale[token].one.withPrepositionIn;
                }
                else {
                    result = distanceInWordsLocale[token].one.withPrepositionAgo;
                }
            }
            else {
                result = distanceInWordsLocale[token].one.standalone;
            }
        }
        else if (count % 10 > 1 && count % 10 < 5 && // if last digit is between 2 and 4
            String(count).substr(-2, 1) !== '1' // unless the 2nd to last digit is "1"
        ) {
            result = distanceInWordsLocale[token].dual.replace('{{count}}', count);
        }
        else {
            result = distanceInWordsLocale[token].other.replace('{{count}}', count);
        }
        if (options.addSuffix) {
            if (options.comparison > 0) {
                return 'za ' + result;
            }
            else {
                return 'prije ' + result;
            }
        }
        return result;
    }
    return {
        localize: localize
    };
}
var build_distance_in_words_locale$50 = buildDistanceInWordsLocale$50;
function buildFormatLocale$50() {
    var months3char = ['sij', 'velj', 'ožu', 'tra', 'svi', 'lip', 'srp', 'kol', 'ruj', 'lis', 'stu', 'pro'];
    var monthsFull = ['siječanj', 'veljača', 'ožujak', 'travanj', 'svibanj', 'lipanj', 'srpanj', 'kolovoz', 'rujan', 'listopad', 'studeni', 'prosinac'];
    var monthsGenitive = ['siječnja', 'veljače', 'ožujka', 'travnja', 'svibnja', 'lipnja', 'srpnja', 'kolovoza', 'rujna', 'listopada', 'studenog', 'prosinca'];
    var weekdays2char = ['ne', 'po', 'ut', 'sr', 'če', 'pe', 'su'];
    var weekdays3char = ['ned', 'pon', 'uto', 'sri', 'čet', 'pet', 'sub'];
    var weekdaysFull = ['nedjelja', 'ponedjeljak', 'utorak', 'srijeda', 'četvrtak', 'petak', 'subota'];
    var meridiemUppercase = ['ujutro', 'popodne'];
    var meridiemLowercase = ['ujutro', 'popodne'];
    var meridiemFull = ['ujutro', 'popodne'];
    var formatters = {
        // Month: Jan, Feb, ..., Dec
        'MMM': function (date) {
            return months3char[date.getMonth()];
        },
        // Month: January, February, ..., December
        'MMMM': function (date) {
            return monthsFull[date.getMonth()];
        },
        // Day of week: Su, Mo, ..., Sa
        'dd': function (date) {
            return weekdays2char[date.getDay()];
        },
        // Day of week: Sun, Mon, ..., Sat
        'ddd': function (date) {
            return weekdays3char[date.getDay()];
        },
        // Day of week: Sunday, Monday, ..., Saturday
        'dddd': function (date) {
            return weekdaysFull[date.getDay()];
        },
        // AM, PM
        'A': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemUppercase[1] : meridiemUppercase[0];
        },
        // am, pm
        'a': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemLowercase[1] : meridiemLowercase[0];
        },
        // a.m., p.m.
        'aa': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemFull[1] : meridiemFull[0];
        }
    };
    // Generate ordinal version of formatters: M -> Mo, D -> Do, etc.
    var ordinalFormatters = ['M', 'D', 'DDD', 'd', 'Q', 'W'];
    ordinalFormatters.forEach(function (formatterToken) {
        formatters[formatterToken + 'o'] = function (date, formatters) {
            return ordinal$18(formatters[formatterToken](date));
        };
    });
    // Generate formatters like 'D MMMM', where the month is in the genitive case
    var monthsGenitiveFormatters = ['D', 'Do', 'DD'];
    monthsGenitiveFormatters.forEach(function (formatterToken) {
        formatters[formatterToken + ' MMM'] = function (date, commonFormatters) {
            var formatter = formatters[formatterToken] || commonFormatters[formatterToken];
            return formatter(date, commonFormatters) + ' ' + monthsGenitive[date.getMonth()];
        };
    });
    return {
        formatters: formatters,
        formattingTokensRegExp: build_formatting_tokens_reg_exp(formatters)
    };
}
function ordinal$18(number) {
    return number + '.';
}
var build_format_locale$50 = buildFormatLocale$50;
/**
 * @category Locales
 * @summary Croatian locale.
 * @author Matija Marohnić [@silvenon]{@link https://github.com/silvenon}
 */
var hr = {
    distanceInWords: build_distance_in_words_locale$50(),
    format: build_format_locale$50()
};
var hr$2 = Object.freeze({
    default: hr,
    __moduleExports: hr
});
function buildDistanceInWordsLocale$52() {
    var distanceInWordsLocale = {
        lessThanXSeconds: {
            one: 'أقل من ثانية واحدة',
            other: 'أقل من {{count}} ثواني'
        },
        xSeconds: {
            one: 'ثانية واحدة',
            other: '{{count}} ثواني'
        },
        halfAMinute: 'نصف دقيقة',
        lessThanXMinutes: {
            one: 'أقل من دقيقة',
            other: 'أقل من {{count}} دقيقة'
        },
        xMinutes: {
            one: 'دقيقة واحدة',
            other: '{{count}} دقائق'
        },
        aboutXHours: {
            one: 'ساعة واحدة تقريباً',
            other: '{{count}} ساعات تقريباً'
        },
        xHours: {
            one: 'ساعة واحدة',
            other: '{{count}} ساعات'
        },
        xDays: {
            one: 'يوم واحد',
            other: '{{count}} أيام'
        },
        aboutXMonths: {
            one: 'شهر واحد تقريباً',
            other: '{{count}} أشهر تقريباً'
        },
        xMonths: {
            one: 'شهر واحد',
            other: '{{count}} أشهر'
        },
        aboutXYears: {
            one: 'عام واحد تقريباً',
            other: '{{count}} أعوام تقريباً'
        },
        xYears: {
            one: 'عام واحد',
            other: '{{count}} أعوام'
        },
        overXYears: {
            one: 'أكثر من عام',
            other: 'أكثر من {{count}} أعوام'
        },
        almostXYears: {
            one: 'عام واحد تقريباً',
            other: '{{count}} أعوام تقريباً'
        }
    };
    function localize(token, count, options) {
        options = options || {};
        var result;
        if (typeof distanceInWordsLocale[token] === 'string') {
            result = distanceInWordsLocale[token];
        }
        else if (count === 1) {
            result = distanceInWordsLocale[token].one;
        }
        else {
            result = distanceInWordsLocale[token].other.replace('{{count}}', count);
        }
        if (options.addSuffix) {
            if (options.comparison > 0) {
                return 'في خلال ' + result;
            }
            else {
                return 'منذ ' + result;
            }
        }
        return result;
    }
    return {
        localize: localize
    };
}
var build_distance_in_words_locale$52 = buildDistanceInWordsLocale$52;
function buildFormatLocale$52() {
    var months3char = ['يناير', 'فبراير', 'مارس', 'أبريل', 'مايو', 'يونيو', 'يوليو', 'أغسطس', 'سبتمبر', 'أكتوبر', 'نوفمبر', 'ديسمبر'];
    var monthsFull = ['كانون الثاني يناير', 'شباط فبراير', 'آذار مارس', 'نيسان أبريل', 'أيار مايو', 'حزيران يونيو', 'تموز يوليو', 'آب أغسطس', 'أيلول سبتمبر', 'تشرين الأول أكتوبر', 'تشرين الثاني نوفمبر', 'كانون الأول ديسمبر'];
    var weekdays2char = ['ح', 'ن', 'ث', 'ر', 'خ', 'ج', 'س'];
    var weekdays3char = ['أحد', 'إثنين', 'ثلاثاء', 'أربعاء', 'خميس', 'جمعة', 'سبت'];
    var weekdaysFull = ['الأحد', 'الإثنين', 'الثلاثاء', 'الأربعاء', 'الخميس', 'الجمعة', 'السبت'];
    var meridiemUppercase = ['صباح', 'مساء'];
    var meridiemLowercase = ['ص', 'م'];
    var meridiemFull = ['صباحاً', 'مساءاً'];
    var formatters = {
        // Month: Jan, Feb, ..., Dec
        'MMM': function (date) {
            return months3char[date.getMonth()];
        },
        // Month: January, February, ..., December
        'MMMM': function (date) {
            return monthsFull[date.getMonth()];
        },
        // Day of week: Su, Mo, ..., Sa
        'dd': function (date) {
            return weekdays2char[date.getDay()];
        },
        // Day of week: Sun, Mon, ..., Sat
        'ddd': function (date) {
            return weekdays3char[date.getDay()];
        },
        // Day of week: Sunday, Monday, ..., Saturday
        'dddd': function (date) {
            return weekdaysFull[date.getDay()];
        },
        // AM, PM
        'A': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemUppercase[1] : meridiemUppercase[0];
        },
        // am, pm
        'a': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemLowercase[1] : meridiemLowercase[0];
        },
        // a.m., p.m.
        'aa': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemFull[1] : meridiemFull[0];
        }
    };
    // Generate ordinal version of formatters: M -> Mo, D -> Do, etc.
    var ordinalFormatters = ['M', 'D', 'DDD', 'd', 'Q', 'W'];
    ordinalFormatters.forEach(function (formatterToken) {
        formatters[formatterToken + 'o'] = function (date, formatters) {
            return ordinal$19(formatters[formatterToken](date));
        };
    });
    return {
        formatters: formatters,
        formattingTokensRegExp: build_formatting_tokens_reg_exp(formatters)
    };
}
function ordinal$19(number) {
    return String(number);
}
var build_format_locale$52 = buildFormatLocale$52;
/**
 * @category Locales
 * @summary Arabic locale (Modern Standard Arabic - Al-fussha).
 * @author Abdallah Hassan [@AbdallahAHO]{@link https://github.com/AbdallahAHO}
 */
var ar = {
    distanceInWords: build_distance_in_words_locale$52(),
    format: build_format_locale$52()
};
var ar$2 = Object.freeze({
    default: ar,
    __moduleExports: ar
});
function buildDistanceInWordsLocale$54() {
    var distanceInWordsLocale = {
        lessThanXSeconds: {
            one: 'по-малко от секунда',
            other: 'по-малко от {{count}} секунди'
        },
        xSeconds: {
            one: '1 секунда',
            other: '{{count}} секунди'
        },
        halfAMinute: 'половин минута',
        lessThanXMinutes: {
            one: 'по-малко от минута',
            other: 'по-малко от {{count}} минути'
        },
        xMinutes: {
            one: '1 минута',
            other: '{{count}} минути'
        },
        aboutXHours: {
            one: 'около час',
            other: 'около {{count}} часа'
        },
        xHours: {
            one: '1 час',
            other: '{{count}} часа'
        },
        xDays: {
            one: '1 ден',
            other: '{{count}} дни'
        },
        aboutXMonths: {
            one: 'около месец',
            other: 'около {{count}} месеца'
        },
        xMonths: {
            one: '1 месец',
            other: '{{count}} месеца'
        },
        aboutXYears: {
            one: 'около година',
            other: 'около {{count}} години'
        },
        xYears: {
            one: '1 година',
            other: '{{count}} години'
        },
        overXYears: {
            one: 'над година',
            other: 'над {{count}} години'
        },
        almostXYears: {
            one: 'почти година',
            other: 'почти {{count}} години'
        }
    };
    function localize(token, count, options) {
        options = options || {};
        var result;
        if (typeof distanceInWordsLocale[token] === 'string') {
            result = distanceInWordsLocale[token];
        }
        else if (count === 1) {
            result = distanceInWordsLocale[token].one;
        }
        else {
            result = distanceInWordsLocale[token].other.replace('{{count}}', count);
        }
        if (options.addSuffix) {
            if (options.comparison > 0) {
                return 'след ' + result;
            }
            else {
                return 'преди ' + result;
            }
        }
        return result;
    }
    return {
        localize: localize
    };
}
var build_distance_in_words_locale$54 = buildDistanceInWordsLocale$54;
function buildFormatLocale$54() {
    var months3char = ['яну', 'фев', 'мар', 'апр', 'май', 'юни', 'юли', 'авг', 'сеп', 'окт', 'ное', 'дек'];
    var monthsFull = ['януари', 'февруари', 'март', 'април', 'май', 'юни', 'юли', 'август', 'септември', 'октомври', 'ноември', 'декември'];
    var weekdays2char = ['нд', 'пн', 'вт', 'ср', 'чт', 'пт', 'сб'];
    var weekdays3char = ['нед', 'пон', 'вто', 'сря', 'чет', 'пет', 'съб'];
    var weekdaysFull = ['неделя', 'понеделник', 'вторник', 'сряда', 'четвъртък', 'петък', 'събота'];
    var meridiem = ['сутринта', 'на обяд', 'следобед', 'вечерта'];
    var timeOfDay = function (date) {
        var hours = date.getHours();
        if (hours >= 4 && hours < 12) {
            return meridiem[0];
        }
        else if (hours >= 12 && hours < 14) {
            return meridiem[1];
        }
        else if (hours >= 14 && hours < 17) {
            return meridiem[2];
        }
        else {
            return meridiem[3];
        }
    };
    var formatters = {
        // Month: Jan, Feb, ..., Dec
        'MMM': function (date) {
            return months3char[date.getMonth()];
        },
        // Month: January, February, ..., December
        'MMMM': function (date) {
            return monthsFull[date.getMonth()];
        },
        // Day of week: Su, Mo, ..., Sa
        'dd': function (date) {
            return weekdays2char[date.getDay()];
        },
        // Day of week: Sun, Mon, ..., Sat
        'ddd': function (date) {
            return weekdays3char[date.getDay()];
        },
        // Day of week: Sunday, Monday, ..., Saturday
        'dddd': function (date) {
            return weekdaysFull[date.getDay()];
        },
        // AM, PM
        'A': timeOfDay,
        // am, pm
        'a': timeOfDay,
        // a.m., p.m.
        'aa': timeOfDay
    };
    // Generate ordinal version of formatters: M -> Mo, D -> Do, etc.
    var ordinalFormatters = ['M', 'D', 'DDD', 'd', 'Q', 'W'];
    ordinalFormatters.forEach(function (formatterToken) {
        formatters[formatterToken + 'o'] = function (date, formatters) {
            return ordinal$20(formatters[formatterToken](date));
        };
    });
    return {
        formatters: formatters,
        formattingTokensRegExp: build_formatting_tokens_reg_exp(formatters)
    };
}
function ordinal$20(number) {
    var rem100 = number % 100;
    if (rem100 > 20 || rem100 < 10) {
        switch (rem100 % 10) {
            case 1:
                return number + '-ви';
            case 2:
                return number + '-ри';
        }
    }
    return number + '-и';
}
var build_format_locale$54 = buildFormatLocale$54;
/**
 * @category Locales
 * @summary Bulgarian locale.
 * @author Nikolay Stoynov [@arvigeus]{@link https://github.com/arvigeus}
 */
var bg = {
    distanceInWords: build_distance_in_words_locale$54(),
    format: build_format_locale$54()
};
var bg$2 = Object.freeze({
    default: bg,
    __moduleExports: bg
});
function declensionGroup$2(scheme, count) {
    if (count === 1) {
        return scheme.one;
    }
    if (count >= 2 && count <= 4) {
        return scheme.twoFour;
    }
    // if count === null || count === 0 || count >= 5
    return scheme.other;
}
function declension$3(scheme, count, time) {
    var group = declensionGroup$2(scheme, count);
    var finalText = group[time] || group;
    return finalText.replace('{{count}}', count);
}
function extractPreposition$1(token) {
    var result = ['lessThan', 'about', 'over', 'almost'].filter(function (preposition) {
        return !!token.match(new RegExp('^' + preposition));
    });
    return result[0];
}
function prefixPreposition$1(preposition) {
    var translation = '';
    if (preposition === 'almost') {
        translation = 'skoro';
    }
    if (preposition === 'about') {
        translation = 'přibližně';
    }
    return translation.length > 0 ? translation + ' ' : '';
}
function suffixPreposition$1(preposition) {
    var translation = '';
    if (preposition === 'lessThan') {
        translation = 'méně než';
    }
    if (preposition === 'over') {
        translation = 'více než';
    }
    return translation.length > 0 ? translation + ' ' : '';
}
function lowercaseFirstLetter$1(string) {
    return string.charAt(0).toLowerCase() + string.slice(1);
}
function buildDistanceInWordsLocale$56() {
    var distanceInWordsLocale = {
        xSeconds: {
            one: {
                regular: 'vteřina',
                past: 'vteřinou',
                future: 'vteřinu'
            },
            twoFour: {
                regular: '{{count}} vteřiny',
                past: '{{count}} vteřinami',
                future: '{{count}} vteřiny'
            },
            other: {
                regular: '{{count}} vteřin',
                past: '{{count}} vteřinami',
                future: '{{count}} vteřin'
            }
        },
        halfAMinute: {
            other: {
                regular: 'půl minuty',
                past: 'půl minutou',
                future: 'půl minuty'
            }
        },
        xMinutes: {
            one: {
                regular: 'minuta',
                past: 'minutou',
                future: 'minutu'
            },
            twoFour: {
                regular: '{{count}} minuty',
                past: '{{count}} minutami',
                future: '{{count}} minuty'
            },
            other: {
                regular: '{{count}} minut',
                past: '{{count}} minutami',
                future: '{{count}} minut'
            }
        },
        xHours: {
            one: {
                regular: 'hodina',
                past: 'hodinou',
                future: 'hodinu'
            },
            twoFour: {
                regular: '{{count}} hodiny',
                past: '{{count}} hodinami',
                future: '{{count}} hodiny'
            },
            other: {
                regular: '{{count}} hodin',
                past: '{{count}} hodinami',
                future: '{{count}} hodin'
            }
        },
        xDays: {
            one: {
                regular: 'den',
                past: 'dnem',
                future: 'den'
            },
            twoFour: {
                regular: '{{count}} dni',
                past: '{{count}} dny',
                future: '{{count}} dni'
            },
            other: {
                regular: '{{count}} dní',
                past: '{{count}} dny',
                future: '{{count}} dní'
            }
        },
        xMonths: {
            one: {
                regular: 'měsíc',
                past: 'měsícem',
                future: 'měsíc'
            },
            twoFour: {
                regular: '{{count}} měsíce',
                past: '{{count}} měsíci',
                future: '{{count}} měsíce'
            },
            other: {
                regular: '{{count}} měsíců',
                past: '{{count}} měsíci',
                future: '{{count}} měsíců'
            }
        },
        xYears: {
            one: {
                regular: 'rok',
                past: 'rokem',
                future: 'rok'
            },
            twoFour: {
                regular: '{{count}} roky',
                past: '{{count}} roky',
                future: '{{count}} roky'
            },
            other: {
                regular: '{{count}} roků',
                past: '{{count}} roky',
                future: '{{count}} roků'
            }
        }
    };
    function localize(token, count, options) {
        options = options || {};
        var preposition = extractPreposition$1(token) || '';
        var key = lowercaseFirstLetter$1(token.substring(preposition.length));
        var scheme = distanceInWordsLocale[key];
        if (!options.addSuffix) {
            return prefixPreposition$1(preposition) + suffixPreposition$1(preposition) + declension$3(scheme, count, 'regular');
        }
        if (options.comparison > 0) {
            return prefixPreposition$1(preposition) + 'za ' + suffixPreposition$1(preposition) + declension$3(scheme, count, 'future');
        }
        else {
            return prefixPreposition$1(preposition) + 'před ' + suffixPreposition$1(preposition) + declension$3(scheme, count, 'past');
        }
    }
    return {
        localize: localize
    };
}
var build_distance_in_words_locale$56 = buildDistanceInWordsLocale$56;
function buildFormatLocale$56() {
    var months3char = ['led', 'úno', 'bře', 'dub', 'kvě', 'čvn', 'čvc', 'srp', 'zář', 'říj', 'lis', 'pro'];
    var monthsFull = ['leden', 'únor', 'březen', 'duben', 'květen', 'červen', 'červenec', 'srpen', 'září', 'říjen', 'listopad', 'prosinec'];
    var weekdays2char = ['ne', 'po', 'út', 'st', 'čt', 'pá', 'so'];
    var weekdays3char = ['ned', 'pon', 'úte', 'stř', 'čtv', 'pát', 'sob'];
    var weekdaysFull = ['neděle', 'pondělí', 'úterý', 'středa', 'čtvrtek', 'pátek', 'sobota'];
    var meridiemUppercase = ['DOP.', 'ODP.'];
    var meridiemLowercase = ['dop.', 'odp.'];
    var meridiemFull = ['dopoledne', 'odpoledne'];
    var formatters = {
        // Month: led, úno, ..., pro
        'MMM': function (date) {
            return months3char[date.getMonth()];
        },
        // Month: leden, únor, ..., prosinec
        'MMMM': function (date) {
            return monthsFull[date.getMonth()];
        },
        // Day of week: ne, po, ..., so
        'dd': function (date) {
            return weekdays2char[date.getDay()];
        },
        // Day of week: ned, pon, ..., sob
        'ddd': function (date) {
            return weekdays3char[date.getDay()];
        },
        // Day of week: neděle, pondělí, ..., sobota
        'dddd': function (date) {
            return weekdaysFull[date.getDay()];
        },
        // DOP., ODP.
        'A': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemUppercase[1] : meridiemUppercase[0];
        },
        // dop., odp.
        'a': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemLowercase[1] : meridiemLowercase[0];
        },
        // dopoledne, odpoledne
        'aa': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemFull[1] : meridiemFull[0];
        }
    };
    // Generate ordinal version of formatters: M -> Mo, D -> Do, etc.
    var ordinalFormatters = ['M', 'D', 'DDD', 'd', 'Q', 'W'];
    ordinalFormatters.forEach(function (formatterToken) {
        formatters[formatterToken + 'o'] = function (date, formatters) {
            return ordinal$21(formatters[formatterToken](date));
        };
    });
    return {
        formatters: formatters,
        formattingTokensRegExp: build_formatting_tokens_reg_exp(formatters)
    };
}
function ordinal$21(number) {
    return number + '.';
}
var build_format_locale$56 = buildFormatLocale$56;
/**
 * @category Locales
 * @summary Czech locale.
 * @author David Rus [@davidrus]{@link https://github.com/davidrus}
 */
var cs = {
    distanceInWords: build_distance_in_words_locale$56(),
    format: build_format_locale$56()
};
var cs$2 = Object.freeze({
    default: cs,
    __moduleExports: cs
});
function buildDistanceInWordsLocale$58() {
    var distanceInWordsLocale = {
        lessThanXSeconds: {
            one: 'помалку од секунда',
            other: 'помалку од {{count}} секунди'
        },
        xSeconds: {
            one: '1 секунда',
            other: '{{count}} секунди'
        },
        halfAMinute: 'половина минута',
        lessThanXMinutes: {
            one: 'помалку од минута',
            other: 'помалку од {{count}} минути'
        },
        xMinutes: {
            one: '1 минута',
            other: '{{count}} минути'
        },
        aboutXHours: {
            one: 'околу 1 час',
            other: 'околу {{count}} часа'
        },
        xHours: {
            one: '1 час',
            other: '{{count}} часа'
        },
        xDays: {
            one: '1 ден',
            other: '{{count}} дена'
        },
        aboutXMonths: {
            one: 'околу 1 месец',
            other: 'околу {{count}} месеци'
        },
        xMonths: {
            one: '1 месец',
            other: '{{count}} месеци'
        },
        aboutXYears: {
            one: 'околу 1 година',
            other: 'околу {{count}} години'
        },
        xYears: {
            one: '1 година',
            other: '{{count}} години'
        },
        overXYears: {
            one: 'повеќе од 1 година',
            other: 'повеќе од {{count}} години'
        },
        almostXYears: {
            one: 'безмалку 1 година',
            other: 'безмалку {{count}} години'
        }
    };
    function localize(token, count, options) {
        options = options || {};
        var result;
        if (typeof distanceInWordsLocale[token] === 'string') {
            result = distanceInWordsLocale[token];
        }
        else if (count === 1) {
            result = distanceInWordsLocale[token].one;
        }
        else {
            result = distanceInWordsLocale[token].other.replace('{{count}}', count);
        }
        if (options.addSuffix) {
            if (options.comparison > 0) {
                return 'за ' + result;
            }
            else {
                return 'пред ' + result;
            }
        }
        return result;
    }
    return {
        localize: localize
    };
}
var build_distance_in_words_locale$58 = buildDistanceInWordsLocale$58;
function buildFormatLocale$58() {
    var months3char = ['јан', 'фев', 'мар', 'апр', 'мај', 'јун', 'јул', 'авг', 'сеп', 'окт', 'ное', 'дек'];
    var monthsFull = ['јануари', 'февруари', 'март', 'април', 'мај', 'јуни', 'јули', 'август', 'септември', 'октомври', 'ноември', 'декември'];
    var weekdays2char = ['не', 'по', 'вт', 'ср', 'че', 'пе', 'са'];
    var weekdays3char = ['нед', 'пон', 'вто', 'сре', 'чет', 'пет', 'саб'];
    var weekdaysFull = ['недела', 'понеделник', 'вторник', 'среда', 'четврток', 'петок', 'сабота'];
    var meridiem = ['претпладне', 'попладне'];
    var formatters = {
        // Month: Jan, Feb, ..., Dec
        'MMM': function (date) {
            return months3char[date.getMonth()];
        },
        // Month: January, February, ..., December
        'MMMM': function (date) {
            return monthsFull[date.getMonth()];
        },
        // Day of week: Su, Mo, ..., Sa
        'dd': function (date) {
            return weekdays2char[date.getDay()];
        },
        // Day of week: Sun, Mon, ..., Sat
        'ddd': function (date) {
            return weekdays3char[date.getDay()];
        },
        // Day of week: Sunday, Monday, ..., Saturday
        'dddd': function (date) {
            return weekdaysFull[date.getDay()];
        },
        // AM, PM
        'A': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiem[1] : meridiem[0];
        },
        // am, pm
        'a': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiem[1] : meridiem[0];
        },
        // a.m., p.m.
        'aa': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiem[1] : meridiem[0];
        }
    };
    // Generate ordinal version of formatters: M -> Mo, D -> Do, etc.
    var ordinalFormatters = ['M', 'D', 'DDD', 'd', 'Q', 'W'];
    ordinalFormatters.forEach(function (formatterToken) {
        formatters[formatterToken + 'o'] = function (date, formatters) {
            return ordinal$22(formatters[formatterToken](date));
        };
    });
    return {
        formatters: formatters,
        formattingTokensRegExp: build_formatting_tokens_reg_exp(formatters)
    };
}
function ordinal$22(number) {
    var rem100 = number % 100;
    if (rem100 > 20 || rem100 < 10) {
        switch (rem100 % 10) {
            case 1:
                return number + '-ви';
            case 2:
                return number + '-ри';
            case 7:
            case 8:
                return number + '-ми';
        }
    }
    return number + '-ти';
}
var build_format_locale$58 = buildFormatLocale$58;
/**
 * @category Locales
 * @summary Macedonian locale.
 * @author Petar Vlahu [@vlahupetar]{@link https://github.com/vlahupetar}
 */
var mk = {
    distanceInWords: build_distance_in_words_locale$58(),
    format: build_format_locale$58()
};
var mk$2 = Object.freeze({
    default: mk,
    __moduleExports: mk
});
function buildDistanceInWordsLocale$60() {
    var distanceInWordsLocale = {
        lessThanXSeconds: {
            one: 'mai puțin de o secundă',
            other: 'mai puțin de {{count}} secunde'
        },
        xSeconds: {
            one: '1 secundă',
            other: '{{count}} secunde'
        },
        halfAMinute: 'jumătate de minut',
        lessThanXMinutes: {
            one: 'mai puțin de un minut',
            other: 'mai puțin de {{count}} minute'
        },
        xMinutes: {
            one: '1 minut',
            other: '{{count}} minute'
        },
        aboutXHours: {
            one: 'circa 1 oră',
            other: 'circa {{count}} ore'
        },
        xHours: {
            one: '1 oră',
            other: '{{count}} ore'
        },
        xDays: {
            one: '1 zi',
            other: '{{count}} zile'
        },
        aboutXMonths: {
            one: 'circa 1 lună',
            other: 'circa {{count}} luni'
        },
        xMonths: {
            one: '1 lună',
            other: '{{count}} luni'
        },
        aboutXYears: {
            one: 'circa 1 an',
            other: 'circa {{count}} ani'
        },
        xYears: {
            one: '1 an',
            other: '{{count}} ani'
        },
        overXYears: {
            one: 'peste 1 an',
            other: 'peste {{count}} ani'
        },
        almostXYears: {
            one: 'aproape 1 an',
            other: 'aproape {{count}} ani'
        }
    };
    function localize(token, count, options) {
        options = options || {};
        var result;
        if (typeof distanceInWordsLocale[token] === 'string') {
            result = distanceInWordsLocale[token];
        }
        else if (count === 1) {
            result = distanceInWordsLocale[token].one;
        }
        else {
            result = distanceInWordsLocale[token].other.replace('{{count}}', count);
        }
        if (options.addSuffix) {
            if (options.comparison > 0) {
                return 'în ' + result;
            }
            else {
                return result + ' în urmă';
            }
        }
        return result;
    }
    return {
        localize: localize
    };
}
var build_distance_in_words_locale$60 = buildDistanceInWordsLocale$60;
function buildFormatLocale$60() {
    // Note: in Romanian language the weekdays and months should be in the lowercase.
    var months3char = ['ian', 'feb', 'mar', 'apr', 'mai', 'iun', 'iul', 'aug', 'sep', 'oct', 'noi', 'dec'];
    var monthsFull = ['ianuarie', 'februarie', 'martie', 'aprilie', 'mai', 'iunie', 'iulie', 'august', 'septembrie', 'octombrie', 'noiembrie', 'decembrie'];
    var weekdays2char = ['du', 'lu', 'ma', 'mi', 'jo', 'vi', 'sâ'];
    var weekdays3char = ['dum', 'lun', 'mar', 'mie', 'joi', 'vin', 'sâm'];
    var weekdaysFull = ['duminică', 'luni', 'marți', 'miercuri', 'joi', 'vineri', 'sâmbăta'];
    var meridiemUppercase = ['AM', 'PM'];
    var meridiemLowercase = ['am', 'pm'];
    var meridiemFull = ['a.m.', 'p.m.'];
    var formatters = {
        // Month: Jan, Feb, ..., Dec
        'MMM': function (date) {
            return months3char[date.getMonth()];
        },
        // Month: January, February, ..., December
        'MMMM': function (date) {
            return monthsFull[date.getMonth()];
        },
        // Day of week: Su, Mo, ..., Sa
        'dd': function (date) {
            return weekdays2char[date.getDay()];
        },
        // Day of week: Sun, Mon, ..., Sat
        'ddd': function (date) {
            return weekdays3char[date.getDay()];
        },
        // Day of week: Sunday, Monday, ..., Saturday
        'dddd': function (date) {
            return weekdaysFull[date.getDay()];
        },
        // AM, PM
        'A': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemUppercase[1] : meridiemUppercase[0];
        },
        // am, pm
        'a': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemLowercase[1] : meridiemLowercase[0];
        },
        // a.m., p.m.
        'aa': function (date) {
            return (date.getHours() / 12) >= 1 ? meridiemFull[1] : meridiemFull[0];
        }
    };
    // Generate ordinal version of formatters: M -> Mo, D -> Do, etc.
    var ordinalFormatters = ['M', 'D', 'DDD', 'd', 'Q', 'W'];
    ordinalFormatters.forEach(function (formatterToken) {
        formatters[formatterToken + 'o'] = function (date, formatters) {
            return ordinal$23(formatters[formatterToken](date));
        };
    });
    return {
        formatters: formatters,
        formattingTokensRegExp: build_formatting_tokens_reg_exp(formatters)
    };
}
function ordinal$23(number) {
    return number.toString();
}
var build_format_locale$60 = buildFormatLocale$60;
/**
 * @category Locales
 * @summary Romanian locale.
 * @author Sergiu Munteanu [@jsergiu]{@link https://github.com/jsergiu}
 */
var ro = {
    distanceInWords: build_distance_in_words_locale$60(),
    format: build_format_locale$60()
};
var ro$2 = Object.freeze({
    default: ro,
    __moduleExports: ro
});
var localeArray = [
    ["arabic" /* ARABIC */, ar$2],
    ["bulgarian" /* BULGARIAN */, bg$2],
    ["catalan" /* CATALAN */, ca$2],
    ["chinese simplified" /* CHINESE_SIMPLIFIED */, zh_cn$2],
    ["chinese traditional" /* CHINESE_TRADITIONAL */, zh_cn$2],
    ["croatian" /* CROATIAN */, hr$2],
    ["czech" /* CZECH */, cs$2],
    ["danish" /* DANISH */, da$2],
    ["dutch" /* DUTCH */, nl$2],
    ["english" /* ENGLISH */, en$2],
    ["esperanto" /* ESPERANTO */, eo$2],
    ["filipino" /* FILIPINO */, fil$2],
    ["finnish" /* FINNISH */, fi$2],
    ["french" /* FRENCH */, fr$2],
    ["german" /* GERMAN */, de$2],
    ["greek" /* GREEK */, el$2],
    ["icelandic" /* ICELANDIC */, is$2],
    ["indonesian" /* INDONESIAN */, id$2],
    ["italian" /* ITALIAN */, it$2],
    ["japanese" /* JAPANESE */, ja$2],
    ["korean" /* KOREAN */, ko$2],
    ["macedonian" /* MACEDONIAN */, mk$2],
    ["norwegian bokmal" /* NORWEIGAN_BOKMAL */, nb$2],
    ["polish" /* POLISH */, pl$2],
    ["portuguese" /* PORTUGUESE */, pt$2],
    ["romanian" /* ROMANIAN */, ro$2],
    ["russian" /* RUSSIAN */, ru$2],
    ["slovak" /* SLOVAK */, sk$2],
    ["spanish" /* SPANISH */, es$2],
    ["swedish" /* SWEDISH */, sv$2],
    ["thai" /* THAI */, th$2],
    ["turkish" /* TURKISH */, tr$2]
];
var localeMap = new Map(localeArray);
/**
 * @param {?} locale
 * @return {?}
 */
function getLocale(locale) {
    return localeMap.get(locale);
}
// Locale Manager by Aaron Sterling
var DEFAULT_LOCALE_TOKEN = new InjectionToken('default locale');
var DEFAULT_LOCALE = "english";
var LocaleManager = /** @class */ (function () {
    /**
     * @param {?} userProvidedLocale
     */
    function LocaleManager(userProvidedLocale) {
        this.defaultLocale = DEFAULT_LOCALE;
        this.localeToRevertTo = DEFAULT_LOCALE;
        if (userProvidedLocale) {
            this.defaultLocale = userProvidedLocale;
            this.localeToRevertTo = userProvidedLocale;
        }
    }
    /**
     * @param {?} newDefaultLocale
     * @return {?}
     */
    LocaleManager.prototype.setDefaultLocale = function (newDefaultLocale) {
        this.defaultLocale = newDefaultLocale;
    };
    /**
     * @return {?}
     */
    LocaleManager.prototype.getDefaultLocale = function () {
        return this.defaultLocale;
    };
    /**
     * @return {?}
     */
    LocaleManager.prototype.getFullLocale = function () {
        return getLocale(this.defaultLocale);
    };
    /**
     * @return {?}
     */
    LocaleManager.prototype.resetDefaultLocale = function () {
        this.defaultLocale = this.localeToRevertTo;
    };
    return LocaleManager;
}());
LocaleManager.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
LocaleManager.ctorParameters = function () { return [
    { type: Locale, decorators: [{ type: Inject, args: [DEFAULT_LOCALE_TOKEN,] },] },
]; };
var DatePipe = /** @class */ (function () {
    /**
     * Input can be a string, number or Date
     * Pipe returns the output of the date-fns format function
     * @param {?} manager
     * @param {?} localeManager
     */
    function DatePipe(manager, localeManager) {
        this.manager = manager;
        this.localeManager = localeManager;
    }
    /**
     * @param {?} value
     * @param {?=} dateFormat
     * @return {?}
     */
    DatePipe.prototype.transform = function (value, dateFormat) {
        var /** @type {?} */ formatToUse = this.manager.getDefaultFormat(dateFormat);
        var /** @type {?} */ localeToUse = this.localeManager.getFullLocale();
        return format_1(value, formatToUse, { locale: localeToUse });
    };
    return DatePipe;
}());
DatePipe.decorators = [
    { type: Pipe, args: [{
                name: 'date',
            },] },
];
/**
 * @nocollapse
 */
DatePipe.ctorParameters = function () { return [
    { type: DatePipeManager, },
    { type: LocaleManager, },
]; };
/**
 * @category Common Helpers
 * @summary Return the latest of the given dates.
 *
 * @description
 * Return the latest of the given dates.
 *
 * @param {...(Date|String|Number)} dates - the dates to compare
 * @returns {Date} the latest of the dates
 *
 * @example
 * // Which of these dates is the latest?
 * var result = max(
 *   new Date(1989, 6, 10),
 *   new Date(1987, 1, 11),
 *   new Date(1995, 6, 2),
 *   new Date(1990, 0, 1)
 * )
 * //=> Sun Jul 02 1995 00:00:00
 */
function max() {
    var dirtyDates = Array.prototype.slice.call(arguments);
    var dates = dirtyDates.map(function (dirtyDate) {
        return parse_1(dirtyDate);
    });
    var latestTimestamp = Math.max.apply(null, dates);
    return new Date(latestTimestamp);
}
var max_1 = max;
var MaxDatePipe = /** @class */ (function () {
    /**
     * Returns the max date from an array of dates
     * @param {?} manager
     * @param {?} localeManager
     */
    function MaxDatePipe(manager, localeManager) {
        this.manager = manager;
        this.localeManager = localeManager;
    }
    /**
     * @param {?} range
     * @param {?=} dateFormat
     * @return {?}
     */
    MaxDatePipe.prototype.transform = function (range, dateFormat) {
        var /** @type {?} */ formatToUse = this.manager.getDefaultFormat(dateFormat);
        var /** @type {?} */ localeToUse = this.localeManager.getFullLocale();
        return format_1(max_1.apply(void 0, range), formatToUse, { locale: localeToUse });
    };
    return MaxDatePipe;
}());
MaxDatePipe.decorators = [
    { type: Pipe, args: [{
                name: 'maxDate',
            },] },
];
/**
 * @nocollapse
 */
MaxDatePipe.ctorParameters = function () { return [
    { type: DatePipeManager, },
    { type: LocaleManager, },
]; };
/**
 * @category Common Helpers
 * @summary Return the earliest of the given dates.
 *
 * @description
 * Return the earliest of the given dates.
 *
 * @param {...(Date|String|Number)} dates - the dates to compare
 * @returns {Date} the earliest of the dates
 *
 * @example
 * // Which of these dates is the earliest?
 * var result = min(
 *   new Date(1989, 6, 10),
 *   new Date(1987, 1, 11),
 *   new Date(1995, 6, 2),
 *   new Date(1990, 0, 1)
 * )
 * //=> Wed Feb 11 1987 00:00:00
 */
function min() {
    var dirtyDates = Array.prototype.slice.call(arguments);
    var dates = dirtyDates.map(function (dirtyDate) {
        return parse_1(dirtyDate);
    });
    var earliestTimestamp = Math.min.apply(null, dates);
    return new Date(earliestTimestamp);
}
var min_1 = min;
var MinDatePipe = /** @class */ (function () {
    /**
     * Returns the min date from a range of dates
     * @param {?} manager
     * @param {?} localeManager
     */
    function MinDatePipe(manager, localeManager) {
        this.manager = manager;
        this.localeManager = localeManager;
    }
    /**
     * @param {?} range
     * @param {?=} dateFormat
     * @return {?}
     */
    MinDatePipe.prototype.transform = function (range, dateFormat) {
        var /** @type {?} */ formatToUse = this.manager.getDefaultFormat(dateFormat);
        var /** @type {?} */ localeToUse = this.localeManager.getFullLocale();
        return format_1(min_1.apply(void 0, range), formatToUse, { locale: localeToUse });
    };
    return MinDatePipe;
}());
MinDatePipe.decorators = [
    { type: Pipe, args: [{
                name: 'minDate',
            },] },
];
/**
 * @nocollapse
 */
MinDatePipe.ctorParameters = function () { return [
    { type: DatePipeManager, },
    { type: LocaleManager, },
]; };
/**
 * @category Common Helpers
 * @summary Compare the two dates reverse chronologically and return -1, 0 or 1.
 *
 * @description
 * Compare the two dates and return -1 if the first date is after the second,
 * 1 if the first date is before the second or 0 if dates are equal.
 *
 * @param {Date|String|Number} dateLeft - the first date to compare
 * @param {Date|String|Number} dateRight - the second date to compare
 * @returns {Number} the result of the comparison
 *
 * @example
 * // Compare 11 February 1987 and 10 July 1989 reverse chronologically:
 * var result = compareDesc(
 *   new Date(1987, 1, 11),
 *   new Date(1989, 6, 10)
 * )
 * //=> 1
 *
 * @example
 * // Sort the array of dates in reverse chronological order:
 * var result = [
 *   new Date(1995, 6, 2),
 *   new Date(1987, 1, 11),
 *   new Date(1989, 6, 10)
 * ].sort(compareDesc)
 * //=> [
 * //   Sun Jul 02 1995 00:00:00,
 * //   Mon Jul 10 1989 00:00:00,
 * //   Wed Feb 11 1987 00:00:00
 * // ]
 */
function compareDesc(dirtyDateLeft, dirtyDateRight) {
    var dateLeft = parse_1(dirtyDateLeft);
    var timeLeft = dateLeft.getTime();
    var dateRight = parse_1(dirtyDateRight);
    var timeRight = dateRight.getTime();
    if (timeLeft > timeRight) {
        return -1;
    }
    else if (timeLeft < timeRight) {
        return 1;
    }
    else {
        return 0;
    }
}
var compare_desc = compareDesc;
/**
 * @category Millisecond Helpers
 * @summary Get the number of milliseconds between the given dates.
 *
 * @description
 * Get the number of milliseconds between the given dates.
 *
 * @param {Date|String|Number} dateLeft - the later date
 * @param {Date|String|Number} dateRight - the earlier date
 * @returns {Number} the number of milliseconds
 *
 * @example
 * // How many milliseconds are between
 * // 2 July 2014 12:30:20.600 and 2 July 2014 12:30:21.700?
 * var result = differenceInMilliseconds(
 *   new Date(2014, 6, 2, 12, 30, 21, 700),
 *   new Date(2014, 6, 2, 12, 30, 20, 600)
 * )
 * //=> 1100
 */
function differenceInMilliseconds(dirtyDateLeft, dirtyDateRight) {
    var dateLeft = parse_1(dirtyDateLeft);
    var dateRight = parse_1(dirtyDateRight);
    return dateLeft.getTime() - dateRight.getTime();
}
var difference_in_milliseconds = differenceInMilliseconds;
/**
 * @category Second Helpers
 * @summary Get the number of seconds between the given dates.
 *
 * @description
 * Get the number of seconds between the given dates.
 *
 * @param {Date|String|Number} dateLeft - the later date
 * @param {Date|String|Number} dateRight - the earlier date
 * @returns {Number} the number of seconds
 *
 * @example
 * // How many seconds are between
 * // 2 July 2014 12:30:07.999 and 2 July 2014 12:30:20.000?
 * var result = differenceInSeconds(
 *   new Date(2014, 6, 2, 12, 30, 20, 0),
 *   new Date(2014, 6, 2, 12, 30, 7, 999)
 * )
 * //=> 12
 */
function differenceInSeconds(dirtyDateLeft, dirtyDateRight) {
    var diff = difference_in_milliseconds(dirtyDateLeft, dirtyDateRight) / 1000;
    return diff > 0 ? Math.floor(diff) : Math.ceil(diff);
}
var difference_in_seconds = differenceInSeconds;
/**
 * @category Month Helpers
 * @summary Get the number of calendar months between the given dates.
 *
 * @description
 * Get the number of calendar months between the given dates.
 *
 * @param {Date|String|Number} dateLeft - the later date
 * @param {Date|String|Number} dateRight - the earlier date
 * @returns {Number} the number of calendar months
 *
 * @example
 * // How many calendar months are between 31 January 2014 and 1 September 2014?
 * var result = differenceInCalendarMonths(
 *   new Date(2014, 8, 1),
 *   new Date(2014, 0, 31)
 * )
 * //=> 8
 */
function differenceInCalendarMonths(dirtyDateLeft, dirtyDateRight) {
    var dateLeft = parse_1(dirtyDateLeft);
    var dateRight = parse_1(dirtyDateRight);
    var yearDiff = dateLeft.getFullYear() - dateRight.getFullYear();
    var monthDiff = dateLeft.getMonth() - dateRight.getMonth();
    return yearDiff * 12 + monthDiff;
}
var difference_in_calendar_months = differenceInCalendarMonths;
/**
 * @category Common Helpers
 * @summary Compare the two dates and return -1, 0 or 1.
 *
 * @description
 * Compare the two dates and return 1 if the first date is after the second,
 * -1 if the first date is before the second or 0 if dates are equal.
 *
 * @param {Date|String|Number} dateLeft - the first date to compare
 * @param {Date|String|Number} dateRight - the second date to compare
 * @returns {Number} the result of the comparison
 *
 * @example
 * // Compare 11 February 1987 and 10 July 1989:
 * var result = compareAsc(
 *   new Date(1987, 1, 11),
 *   new Date(1989, 6, 10)
 * )
 * //=> -1
 *
 * @example
 * // Sort the array of dates:
 * var result = [
 *   new Date(1995, 6, 2),
 *   new Date(1987, 1, 11),
 *   new Date(1989, 6, 10)
 * ].sort(compareAsc)
 * //=> [
 * //   Wed Feb 11 1987 00:00:00,
 * //   Mon Jul 10 1989 00:00:00,
 * //   Sun Jul 02 1995 00:00:00
 * // ]
 */
function compareAsc(dirtyDateLeft, dirtyDateRight) {
    var dateLeft = parse_1(dirtyDateLeft);
    var timeLeft = dateLeft.getTime();
    var dateRight = parse_1(dirtyDateRight);
    var timeRight = dateRight.getTime();
    if (timeLeft < timeRight) {
        return -1;
    }
    else if (timeLeft > timeRight) {
        return 1;
    }
    else {
        return 0;
    }
}
var compare_asc = compareAsc;
/**
 * @category Month Helpers
 * @summary Get the number of full months between the given dates.
 *
 * @description
 * Get the number of full months between the given dates.
 *
 * @param {Date|String|Number} dateLeft - the later date
 * @param {Date|String|Number} dateRight - the earlier date
 * @returns {Number} the number of full months
 *
 * @example
 * // How many full months are between 31 January 2014 and 1 September 2014?
 * var result = differenceInMonths(
 *   new Date(2014, 8, 1),
 *   new Date(2014, 0, 31)
 * )
 * //=> 7
 */
function differenceInMonths(dirtyDateLeft, dirtyDateRight) {
    var dateLeft = parse_1(dirtyDateLeft);
    var dateRight = parse_1(dirtyDateRight);
    var sign = compare_asc(dateLeft, dateRight);
    var difference = Math.abs(difference_in_calendar_months(dateLeft, dateRight));
    dateLeft.setMonth(dateLeft.getMonth() - sign * difference);
    // Math.abs(diff in full months - diff in calendar months) === 1 if last calendar month is not full
    // If so, result must be decreased by 1 in absolute value
    var isLastMonthNotFull = compare_asc(dateLeft, dateRight) === -sign;
    return sign * (difference - isLastMonthNotFull);
}
var difference_in_months = differenceInMonths;
var MINUTES_IN_DAY = 1440;
var MINUTES_IN_ALMOST_TWO_DAYS = 2520;
var MINUTES_IN_MONTH = 43200;
var MINUTES_IN_TWO_MONTHS = 86400;
/**
 * @category Common Helpers
 * @summary Return the distance between the given dates in words.
 *
 * @description
 * Return the distance between the given dates in words.
 *
 * | Distance between dates                                            | Result              |
 * |-------------------------------------------------------------------|---------------------|
 * | 0 ... 30 secs                                                     | less than a minute  |
 * | 30 secs ... 1 min 30 secs                                         | 1 minute            |
 * | 1 min 30 secs ... 44 mins 30 secs                                 | [2..44] minutes     |
 * | 44 mins ... 30 secs ... 89 mins 30 secs                           | about 1 hour        |
 * | 89 mins 30 secs ... 23 hrs 59 mins 30 secs                        | about [2..24] hours |
 * | 23 hrs 59 mins 30 secs ... 41 hrs 59 mins 30 secs                 | 1 day               |
 * | 41 hrs 59 mins 30 secs ... 29 days 23 hrs 59 mins 30 secs         | [2..30] days        |
 * | 29 days 23 hrs 59 mins 30 secs ... 44 days 23 hrs 59 mins 30 secs | about 1 month       |
 * | 44 days 23 hrs 59 mins 30 secs ... 59 days 23 hrs 59 mins 30 secs | about 2 months      |
 * | 59 days 23 hrs 59 mins 30 secs ... 1 yr                           | [2..12] months      |
 * | 1 yr ... 1 yr 3 months                                            | about 1 year        |
 * | 1 yr 3 months ... 1 yr 9 month s                                  | over 1 year         |
 * | 1 yr 9 months ... 2 yrs                                           | almost 2 years      |
 * | N yrs ... N yrs 3 months                                          | about N years       |
 * | N yrs 3 months ... N yrs 9 months                                 | over N years        |
 * | N yrs 9 months ... N+1 yrs                                        | almost N+1 years    |
 *
 * With `options.includeSeconds == true`:
 * | Distance between dates | Result               |
 * |------------------------|----------------------|
 * | 0 secs ... 5 secs      | less than 5 seconds  |
 * | 5 secs ... 10 secs     | less than 10 seconds |
 * | 10 secs ... 20 secs    | less than 20 seconds |
 * | 20 secs ... 40 secs    | half a minute        |
 * | 40 secs ... 60 secs    | less than a minute   |
 * | 60 secs ... 90 secs    | 1 minute             |
 *
 * @param {Date|String|Number} dateToCompare - the date to compare with
 * @param {Date|String|Number} date - the other date
 * @param {Object} [options] - the object with options
 * @param {Boolean} [options.includeSeconds=false] - distances less than a minute are more detailed
 * @param {Boolean} [options.addSuffix=false] - result indicates if the second date is earlier or later than the first
 * @param {Object} [options.locale=enLocale] - the locale object
 * @returns {String} the distance in words
 *
 * @example
 * // What is the distance between 2 July 2014 and 1 January 2015?
 * var result = distanceInWords(
 *   new Date(2014, 6, 2),
 *   new Date(2015, 0, 1)
 * )
 * //=> '6 months'
 *
 * @example
 * // What is the distance between 1 January 2015 00:00:15
 * // and 1 January 2015 00:00:00, including seconds?
 * var result = distanceInWords(
 *   new Date(2015, 0, 1, 0, 0, 15),
 *   new Date(2015, 0, 1, 0, 0, 0),
 *   {includeSeconds: true}
 * )
 * //=> 'less than 20 seconds'
 *
 * @example
 * // What is the distance from 1 January 2016
 * // to 1 January 2015, with a suffix?
 * var result = distanceInWords(
 *   new Date(2016, 0, 1),
 *   new Date(2015, 0, 1),
 *   {addSuffix: true}
 * )
 * //=> 'about 1 year ago'
 *
 * @example
 * // What is the distance between 1 August 2016 and 1 January 2015 in Esperanto?
 * var eoLocale = require('date-fns/locale/eo')
 * var result = distanceInWords(
 *   new Date(2016, 7, 1),
 *   new Date(2015, 0, 1),
 *   {locale: eoLocale}
 * )
 * //=> 'pli ol 1 jaro'
 */
function distanceInWords(dirtyDateToCompare, dirtyDate, dirtyOptions) {
    var options = dirtyOptions || {};
    var comparison = compare_desc(dirtyDateToCompare, dirtyDate);
    var locale = options.locale;
    var localize = en.distanceInWords.localize;
    if (locale && locale.distanceInWords && locale.distanceInWords.localize) {
        localize = locale.distanceInWords.localize;
    }
    var localizeOptions = {
        addSuffix: Boolean(options.addSuffix),
        comparison: comparison
    };
    var dateLeft, dateRight;
    if (comparison > 0) {
        dateLeft = parse_1(dirtyDateToCompare);
        dateRight = parse_1(dirtyDate);
    }
    else {
        dateLeft = parse_1(dirtyDate);
        dateRight = parse_1(dirtyDateToCompare);
    }
    var seconds = difference_in_seconds(dateRight, dateLeft);
    var offset = dateRight.getTimezoneOffset() - dateLeft.getTimezoneOffset();
    var minutes = Math.round(seconds / 60) - offset;
    var months;
    // 0 up to 2 mins
    if (minutes < 2) {
        if (options.includeSeconds) {
            if (seconds < 5) {
                return localize('lessThanXSeconds', 5, localizeOptions);
            }
            else if (seconds < 10) {
                return localize('lessThanXSeconds', 10, localizeOptions);
            }
            else if (seconds < 20) {
                return localize('lessThanXSeconds', 20, localizeOptions);
            }
            else if (seconds < 40) {
                return localize('halfAMinute', null, localizeOptions);
            }
            else if (seconds < 60) {
                return localize('lessThanXMinutes', 1, localizeOptions);
            }
            else {
                return localize('xMinutes', 1, localizeOptions);
            }
        }
        else {
            if (minutes === 0) {
                return localize('lessThanXMinutes', 1, localizeOptions);
            }
            else {
                return localize('xMinutes', minutes, localizeOptions);
            }
        }
        // 2 mins up to 0.75 hrs
    }
    else if (minutes < 45) {
        return localize('xMinutes', minutes, localizeOptions);
        // 0.75 hrs up to 1.5 hrs
    }
    else if (minutes < 90) {
        return localize('aboutXHours', 1, localizeOptions);
        // 1.5 hrs up to 24 hrs
    }
    else if (minutes < MINUTES_IN_DAY) {
        var hours = Math.round(minutes / 60);
        return localize('aboutXHours', hours, localizeOptions);
        // 1 day up to 1.75 days
    }
    else if (minutes < MINUTES_IN_ALMOST_TWO_DAYS) {
        return localize('xDays', 1, localizeOptions);
        // 1.75 days up to 30 days
    }
    else if (minutes < MINUTES_IN_MONTH) {
        var days = Math.round(minutes / MINUTES_IN_DAY);
        return localize('xDays', days, localizeOptions);
        // 1 month up to 2 months
    }
    else if (minutes < MINUTES_IN_TWO_MONTHS) {
        months = Math.round(minutes / MINUTES_IN_MONTH);
        return localize('aboutXMonths', months, localizeOptions);
    }
    months = difference_in_months(dateRight, dateLeft);
    // 2 months up to 12 months
    if (months < 12) {
        var nearestMonth = Math.round(minutes / MINUTES_IN_MONTH);
        return localize('xMonths', nearestMonth, localizeOptions);
        // 1 year up to max Date
    }
    else {
        var monthsSinceStartOfYear = months % 12;
        var years = Math.floor(months / 12);
        // N years up to 1 years 3 months
        if (monthsSinceStartOfYear < 3) {
            return localize('aboutXYears', years, localizeOptions);
            // N years 3 months up to N years 9 months
        }
        else if (monthsSinceStartOfYear < 9) {
            return localize('overXYears', years, localizeOptions);
            // N years 9 months up to N year 12 months
        }
        else {
            return localize('almostXYears', years + 1, localizeOptions);
        }
    }
}
var distance_in_words = distanceInWords;
/**
 * distance in words pipe by Aaron Sterling
 * takes as input an array of two dates
 * outputs the value of the date-fns DistanceInWords function
 */
var DistanceBetweenDatesPipe = /** @class */ (function () {
    /**
     * @param {?} manager
     * @param {?} localeManager
     */
    function DistanceBetweenDatesPipe(manager, localeManager) {
        this.manager = manager;
        this.localeManager = localeManager;
    }
    /**
     * @param {?} dates
     * @return {?}
     */
    DistanceBetweenDatesPipe.prototype.transform = function (dates) {
        var /** @type {?} */ localeToUse = this.localeManager.getFullLocale();
        if (this.manager.secondsIncludedInDistance()) {
            return distance_in_words(dates[0], dates[1], { includeSeconds: true, locale: localeToUse });
        }
        else {
            return distance_in_words(dates[0], dates[1], { includeSeconds: false, locale: localeToUse });
        }
    };
    return DistanceBetweenDatesPipe;
}());
DistanceBetweenDatesPipe.decorators = [
    { type: Pipe, args: [{
                name: 'distanceBetweenDates',
            },] },
];
/**
 * @nocollapse
 */
DistanceBetweenDatesPipe.ctorParameters = function () { return [
    { type: DatePipeManager, },
    { type: LocaleManager, },
]; };
/**
 * @category Common Helpers
 * @summary Return the distance between the given date and now in words.
 *
 * @description
 * Return the distance between the given date and now in words.
 *
 * | Distance to now                                                   | Result              |
 * |-------------------------------------------------------------------|---------------------|
 * | 0 ... 30 secs                                                     | less than a minute  |
 * | 30 secs ... 1 min 30 secs                                         | 1 minute            |
 * | 1 min 30 secs ... 44 mins 30 secs                                 | [2..44] minutes     |
 * | 44 mins ... 30 secs ... 89 mins 30 secs                           | about 1 hour        |
 * | 89 mins 30 secs ... 23 hrs 59 mins 30 secs                        | about [2..24] hours |
 * | 23 hrs 59 mins 30 secs ... 41 hrs 59 mins 30 secs                 | 1 day               |
 * | 41 hrs 59 mins 30 secs ... 29 days 23 hrs 59 mins 30 secs         | [2..30] days        |
 * | 29 days 23 hrs 59 mins 30 secs ... 44 days 23 hrs 59 mins 30 secs | about 1 month       |
 * | 44 days 23 hrs 59 mins 30 secs ... 59 days 23 hrs 59 mins 30 secs | about 2 months      |
 * | 59 days 23 hrs 59 mins 30 secs ... 1 yr                           | [2..12] months      |
 * | 1 yr ... 1 yr 3 months                                            | about 1 year        |
 * | 1 yr 3 months ... 1 yr 9 month s                                  | over 1 year         |
 * | 1 yr 9 months ... 2 yrs                                           | almost 2 years      |
 * | N yrs ... N yrs 3 months                                          | about N years       |
 * | N yrs 3 months ... N yrs 9 months                                 | over N years        |
 * | N yrs 9 months ... N+1 yrs                                        | almost N+1 years    |
 *
 * With `options.includeSeconds == true`:
 * | Distance to now     | Result               |
 * |---------------------|----------------------|
 * | 0 secs ... 5 secs   | less than 5 seconds  |
 * | 5 secs ... 10 secs  | less than 10 seconds |
 * | 10 secs ... 20 secs | less than 20 seconds |
 * | 20 secs ... 40 secs | half a minute        |
 * | 40 secs ... 60 secs | less than a minute   |
 * | 60 secs ... 90 secs | 1 minute             |
 *
 * @param {Date|String|Number} date - the given date
 * @param {Object} [options] - the object with options
 * @param {Boolean} [options.includeSeconds=false] - distances less than a minute are more detailed
 * @param {Boolean} [options.addSuffix=false] - result specifies if the second date is earlier or later than the first
 * @param {Object} [options.locale=enLocale] - the locale object
 * @returns {String} the distance in words
 *
 * @example
 * // If today is 1 January 2015, what is the distance to 2 July 2014?
 * var result = distanceInWordsToNow(
 *   new Date(2014, 6, 2)
 * )
 * //=> '6 months'
 *
 * @example
 * // If now is 1 January 2015 00:00:00,
 * // what is the distance to 1 January 2015 00:00:15, including seconds?
 * var result = distanceInWordsToNow(
 *   new Date(2015, 0, 1, 0, 0, 15),
 *   {includeSeconds: true}
 * )
 * //=> 'less than 20 seconds'
 *
 * @example
 * // If today is 1 January 2015,
 * // what is the distance to 1 January 2016, with a suffix?
 * var result = distanceInWordsToNow(
 *   new Date(2016, 0, 1),
 *   {addSuffix: true}
 * )
 * //=> 'in about 1 year'
 *
 * @example
 * // If today is 1 January 2015,
 * // what is the distance to 1 August 2016 in Esperanto?
 * var eoLocale = require('date-fns/locale/eo')
 * var result = distanceInWordsToNow(
 *   new Date(2016, 7, 1),
 *   {locale: eoLocale}
 * )
 * //=> 'pli ol 1 jaro'
 */
function distanceInWordsToNow(dirtyDate, dirtyOptions) {
    return distance_in_words(Date.now(), dirtyDate, dirtyOptions);
}
var distance_in_words_to_now = distanceInWordsToNow;
// time ago pipe
var TimeAgoPipe = /** @class */ (function () {
    /**
     * @param {?} manager
     * @param {?} localeManager
     */
    function TimeAgoPipe(manager, localeManager) {
        var _this = this;
        this.localeManager = localeManager;
        this.refresher = new Subscription$1();
        this.refreshNow = false;
        this.previousAgoExpression = '';
        this.options = manager.getAgoPipeOptions();
        this.refresher = Observable$1.interval(this.options.refreshRate).startWith(0).subscribe(function (_) { return _this.refreshNow = true; });
    }
    /**
     * @return {?}
     */
    TimeAgoPipe.prototype.ngOnDestroy = function () {
        this.refresher.unsubscribe();
    };
    /**
     * @param {?} inputTime
     * @return {?}
     */
    TimeAgoPipe.prototype.transform = function (inputTime) {
        if (this.refreshNow) {
            this.refreshNow = false;
            var /** @type {?} */ newAgoExpression = this.agoExpression(inputTime);
            this.previousAgoExpression = newAgoExpression;
            return newAgoExpression;
        }
        else {
            return this.previousAgoExpression;
        }
    };
    /**
     * @param {?} inputTime
     * @return {?}
     */
    TimeAgoPipe.prototype.agoExpression = function (inputTime) {
        var /** @type {?} */ localeToUse = this.localeManager.getFullLocale();
        var /** @type {?} */ timeText = distance_in_words_to_now(inputTime, { includeSeconds: this.options.includeSeconds, locale: localeToUse });
        var /** @type {?} */ expression = this.options.prefix + timeText + this.options.suffix;
        return expression;
    };
    return TimeAgoPipe;
}());
TimeAgoPipe.decorators = [
    { type: Pipe, args: [{ name: 'ago', pure: false },] },
];
/**
 * @nocollapse
 */
TimeAgoPipe.ctorParameters = function () { return [
    { type: DatePipeManager, },
    { type: LocaleManager, },
]; };
var DatePipesModule = /** @class */ (function () {
    function DatePipesModule() {
    }
    /**
     * @param {?=} config
     * @param {?=} locale
     * @return {?}
     */
    DatePipesModule.forRoot = function (config, locale) {
        return {
            ngModule: DatePipesModule,
            providers: [
                { provide: DATE_PIPE_CONFIGURATION_TOKEN, useValue: config },
                { provide: DEFAULT_LOCALE_TOKEN, useValue: locale }
            ]
        };
    };
    return DatePipesModule;
}());
DatePipesModule.decorators = [
    { type: NgModule, args: [{
                declarations: [DatePipe,
                    MaxDatePipe,
                    MinDatePipe,
                    DistanceBetweenDatesPipe,
                    TimeAgoPipe
                ],
                providers: [
                    DatePipeManager,
                    LocaleManager
                ],
                imports: [],
                exports: [
                    DatePipe,
                    MaxDatePipe,
                    MinDatePipe,
                    DistanceBetweenDatesPipe,
                    TimeAgoPipe
                ]
            },] },
];
/**
 * @nocollapse
 */
DatePipesModule.ctorParameters = function () { return []; };
/**
 * Generated bundle index. Do not edit.
 */
export { DatePipesModule, DatePipe, DistanceBetweenDatesPipe, MaxDatePipe, MinDatePipe, DatePipeManager, LocaleManager, DATE_PIPE_CONFIGURATION_TOKEN as ɵa, DEFAULT_LOCALE_TOKEN as ɵb, TimeAgoPipe as ɵc };
//# sourceMappingURL=ng-datefns-pipes-all-locales.es5.js.map
